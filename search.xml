<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>入门经典第三章之字符串（上）</title>
    <url>/2020/07/30/UVaOJ2/</url>
    <content><![CDATA[<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css">
    <script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script>
    <!-- require MetingJS -->
    <script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script>

<pre><code>&lt;meting-js
    server=&quot;netease&quot;
    type=&quot;playlist&quot;
    id=&quot;60198&quot;&gt;
&lt;/meting-js&gt;</code></pre><p>第三章主要介绍数组和字符串在算法中的应用，原书基于C语言风格字符数组，介绍sprintf, strchr等string.h库中方法。在本篇博客中记录与之对应cpp对于vector, string的处理方法。</p>
<p>在知识构建方面，我倾向于按照以下思路逐步递进：</p>
<ul>
<li>1 数据结构的定义与初始化</li>
<li>2 定义在数据结构上的基本操作</li>
<li>3 遍历访问</li>
</ul>
<a id="more"></a>

<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="初始化-amp-赋值"><a href="#初始化-amp-赋值" class="headerlink" title="初始化 &amp; 赋值"></a>初始化 &amp; 赋值</h3><p>初始化可分为<strong>直接初始化</strong>与<strong>拷贝初始化</strong>。<br>赋值可用=或assign函数进行字符串赋值，其中assign返回值为字符串的引用。<br><em>初学者需要注意，初始化与赋值并不是同一个概念！</em></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>; <span class="comment">//必要头文件</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    <span class="built_in">string</span> s1; <span class="comment">//默认初始化</span></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">s2</span><span class="params">(<span class="string">"value"</span>)</span></span>; <span class="comment">//直接初始化</span></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">s3</span><span class="params">(<span class="number">3</span>, <span class="string">'c'</span>)</span></span>; <span class="comment">// s3 = "ccc" 直接初始化</span></span><br><span class="line">    <span class="built_in">string</span> s4 = s2; <span class="comment">//拷贝初始化</span></span><br><span class="line">    <span class="comment">//赋值</span></span><br><span class="line">    <span class="built_in">string</span> s5;</span><br><span class="line">    s5 = s4; <span class="comment">//将s4赋值给s5</span></span><br><span class="line">    s5.assign(<span class="string">"12345"</span>); <span class="comment">// s5 = 12345 assgin返回s5的引用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="string对象上的操作"><a href="#string对象上的操作" class="headerlink" title="string对象上的操作"></a>string对象上的操作</h3><h4 id="empty和size"><a href="#empty和size" class="headerlink" title="empty和size"></a>empty和size</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">s.empty() <span class="comment">// s为空返回true，否则返回false</span></span><br><span class="line">s.size() <span class="comment">// 返回s中字符的个数</span></span><br></pre></td></tr></table></figure>

<h5 id="string-size-type类型"><a href="#string-size-type类型" class="headerlink" title="string::size_type类型"></a>string::size_type类型</h5><p>显然，size函数的返回值为int或unsigned int，但其实size函数返回的是一个string::size_type类型的值，此处我们并不需要了解这个类型的细节，但需要明确的是，它是一个unsigned int的值而且足以存放任何string对象的大小。<br><strong>尤为注意的是</strong>，如果在表达式中混用了带符号和无符号数，可能会出现意想不到的结果：例如，假如int n=-1, 则表达式 s.size() &lt; n 为真，<strong>因为负值n会自动地转化为一个比较大的无符号值</strong>。</p>
<p>示例代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">s1</span><span class="params">(<span class="string">"hello"</span>)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">// size与empty操作</span></span><br><span class="line">    <span class="keyword">if</span> (s1.size() &lt; n)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"wrong answer!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// more info</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"s1 is empty? "</span> &lt;&lt; s1.empty() &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"length of s1 is"</span> &lt;&lt; s1.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="字符串比较与拼接"><a href="#字符串比较与拼接" class="headerlink" title="字符串比较与拼接"></a>字符串比较与拼接</h5><h6 id="比较规则"><a href="#比较规则" class="headerlink" title="比较规则"></a>比较规则</h6><p>依<strong>大小写敏感字典序</strong>(A-Za-z升序)进行比较：<br>1.如果两个string对象的长度不同，而且较短string对象的每个字符都与较长string对象对应位置上的字符相同，就说较短string对象小于较长string对象。<br>2.如果两个string对象在某些对应的位置上不一致，则string对象比较的结果其实是string对象中第一对相异字符比较的结果。</p>
<p><strong>比较运算符</strong></p>
<p>&lt;、&lt;=、==、!=、&gt;=、&gt;</p>
<p><em>string对象比较的示例:</em></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> s1 = <span class="string">"abby"</span>;</span><br><span class="line"><span class="built_in">string</span> s2 = <span class="string">"abby finder"</span>;</span><br><span class="line"><span class="built_in">string</span> s3 = <span class="string">"abbY"</span>;</span><br><span class="line"><span class="built_in">string</span> s4 = <span class="string">"Zbby"</span>;</span><br></pre></td></tr></table></figure>

<p>则有<br>s1 &lt; s2, s1 &gt; s3, s1 &gt; s4</p>
<h5 id="字符串拼接"><a href="#字符串拼接" class="headerlink" title="字符串拼接"></a>字符串拼接</h5><h6 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h6><p>对string对象使用加法运算符（+）：<br>一个新的string对象，它所包含的字符由两部分组成：前半部分是加号左侧string对象所含的字符、后半部分是加号右侧string对象所含的字符。<br>复合赋值运算符（+=）：<br>负责把右侧string对象的内容追加到左侧string对象的后面。</p>
<h6 id="append方法"><a href="#append方法" class="headerlink" title="append方法"></a>append方法</h6><p>可直接向原有字符串追加新内容</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> s1 = <span class="string">"Hello"</span>;</span><br><span class="line"><span class="built_in">string</span> s2 = <span class="string">"World"</span>;</span><br><span class="line">s1.append(s2); <span class="comment">// s1 = "HelloWorld"</span></span><br><span class="line"><span class="built_in">string</span> s3 = <span class="string">"Hi"</span>;</span><br><span class="line">s3 += s2; <span class="comment">// s3 = "HiWorld" </span></span><br><span class="line"><span class="built_in">string</span> s4;</span><br><span class="line">s4 = <span class="string">"Good"</span> + s2; <span class="comment">// s4 = "GoodWorld"</span></span><br></pre></td></tr></table></figure>

<h4 id="子串相关操作"><a href="#子串相关操作" class="headerlink" title="子串相关操作"></a>子串相关操作</h4><h5 id="求子串"><a href="#求子串" class="headerlink" title="求子串"></a>求子串</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">substr</span><span class="params">(<span class="keyword">int</span> n = <span class="number">0</span>, <span class="keyword">int</span> m = <span class="built_in">string</span>::npos)</span> <span class="keyword">const</span></span>;</span><br></pre></td></tr></table></figure>
<p>返回原字符串从下标n开始，长度为m的子串，如果省略m，则到字符串结束</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> s1 = <span class="string">"this is ok"</span>;</span><br><span class="line"><span class="built_in">string</span> s2 = s1.substr(<span class="number">2</span>, <span class="number">4</span>);  <span class="comment">// s2 = "is i"</span></span><br><span class="line">s2 = s1.substr(<span class="number">2</span>);  <span class="comment">// s2 = "is is ok"</span></span><br></pre></td></tr></table></figure>

<h5 id="查找子串"><a href="#查找子串" class="headerlink" title="查找子串"></a>查找子串</h5><p>string 类有一些查找子串和字符的成员函数，它们的返回值都是子串或字符在 string 对象字符串中的位置（即下标）。<strong>如果查不到，则返回 string::npos。</strong></p>
<p>函数原型</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">find</span> <span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; str, <span class="keyword">size_t</span> pos = <span class="number">0</span>)</span> <span class="keyword">const</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">rfind</span> <span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; str, <span class="keyword">size_t</span> pos = npos)</span> <span class="keyword">const</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">find_first_of</span> <span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; str, <span class="keyword">size_t</span> pos = <span class="number">0</span>)</span> <span class="keyword">const</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">find_last_of</span> <span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; str, <span class="keyword">size_t</span> pos = npos)</span> <span class="keyword">const</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">find_first_not_of</span> <span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; str, <span class="keyword">size_t</span> pos = <span class="number">0</span>)</span> <span class="keyword">const</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">find_last_not_of</span> <span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; str, <span class="keyword">size_t</span> pos = npos)</span> <span class="keyword">const</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure>

<p>s.find(s2)：<br>find s2 as a substring of s in s1, return the first index of s2 in s1.(find in increasing order)<br>从前往后查找子串或字符出现的位置。<br>s.rfind(s2):<br>find s2 as a substring of s in s1, return the first index of s2 in s1.(find in descending order, result same as find method)<br>从后往前查找子串或字符出现的位置。<br><em>find与rfind返回的结果相同，区别只是在给定特定条件下，顺序查找与逆序查找效率不同</em></p>
<p>s.find_first_of(s2):<br>for char u $\in$ s, if u $\in$ s2, return the first u’s index. (find in increasing order)<br>从前往后查找何处出现另一个字符串中包含的<em>任一<em>字符。<br>s.find_last_of(s2):<br>for char u $\in$ s, if u $\in$ s2, return the first u’s index. (find in descending order)<br>从后往前查找何处出现另一个字符串中包含的</em>任一*字符。<br>*find_first_of与find_last_of返回的结果不同，如果无法查到字符串中的任一字符，则返回string::npos</em></p>
<p>s.find_first_not_of(s2):<br>for char u $\in$ s, if u $\notin$ s2, return the first u’s index. (find in increasing order)<br>从前往后查找何处出现另一个字符串中没有包含的字符<br>s.find_last_not_of(s2):<br>for char u $\in$ s, if u $\notin$ s2, return the first u’s index. (find in descending order)<br>从后往前查找何处出现另一个字符串中没有包含的字符</p>
<h5 id="替换子串"><a href="#替换子串" class="headerlink" title="替换子串"></a>替换子串</h5><p>函数原型</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span>&amp; <span class="title">replace</span> <span class="params">(<span class="keyword">size_t</span> pos, <span class="keyword">size_t</span> len, <span class="keyword">const</span> <span class="built_in">string</span>&amp; str, <span class="keyword">size_t</span> subpos, <span class="keyword">size_t</span> sublen = npos)</span></span>;</span><br></pre></td></tr></table></figure>

<p>s.replace(i, k, s2, j, m)<br>将s的子串s(i,k)(下标从i开始，长度为k的s子串)替换为s2的子串s2(j, m)(下标从j开始，长度为m的s2子串)。</p>
<h5 id="插入子串"><a href="#插入子串" class="headerlink" title="插入子串"></a>插入子串</h5><p>函数原型</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span>&amp; <span class="title">insert</span> <span class="params">(<span class="keyword">size_t</span> pos, <span class="keyword">const</span> <span class="built_in">string</span>&amp; str, <span class="keyword">size_t</span> subpos, <span class="keyword">size_t</span> sublen)</span></span>;</span><br></pre></td></tr></table></figure>

<p>s.insert(i, s2, j, m)<br>字符串s从下标i开始插入子串s2(j,m)(s2下标从j开始，长度为m的子串)</p>
<h5 id="删除子串"><a href="#删除子串" class="headerlink" title="删除子串"></a>删除子串</h5><p>函数原型</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span>&amp; <span class="title">erase</span> <span class="params">(<span class="keyword">size_t</span> pos = <span class="number">0</span>, <span class="keyword">size_t</span> len = npos)</span></span>;</span><br></pre></td></tr></table></figure>

<p>s.erase(i, k)<br>从字符串s中删除s的子串s(i,k)(下标为i, 长度为k的子串)</p>
<h4 id="读写及其他操作"><a href="#读写及其他操作" class="headerlink" title="读写及其他操作"></a>读写及其他操作</h4><h5 id="将string对象作为流处理"><a href="#将string对象作为流处理" class="headerlink" title="将string对象作为流处理"></a>将string对象作为流处理</h5><p>使用流对象 istringstream 和 ostringstream，可以将 string 对象当作一个流进行输入输出。使用这两个类需要包含头文件 sstream。这可与c语言中的sscanf, sprintf对标。</p>
<p>使用IO读入string，string会自动忽略开头的空白（空格符、换行符及制表符等），读取字符串，直到遇到下一个空格(也即字符串以空格进行分割)。</p>
<p>示例代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">src</span><span class="params">(<span class="string">"Avatar 123 5.2 Titanic K"</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">istringstream</span> <span class="title">istrStream</span><span class="params">(src)</span></span>; <span class="comment">//建立src到istrStream的联系</span></span><br><span class="line">    <span class="built_in">string</span> s1, s2;</span><br><span class="line">    <span class="keyword">int</span> n;  <span class="keyword">double</span> d;  <span class="keyword">char</span> c;</span><br><span class="line">    istrStream &gt;&gt; s1 &gt;&gt; n &gt;&gt; d &gt;&gt; s2 &gt;&gt; c; <span class="comment">//把src的内容当做输入流进行读取</span></span><br><span class="line">    <span class="built_in">ostringstream</span> ostrStream;</span><br><span class="line">    ostrStream &lt;&lt; s1 &lt;&lt; <span class="built_in">endl</span> &lt;&lt; s2 &lt;&lt; <span class="built_in">endl</span> &lt;&lt; n &lt;&lt; <span class="built_in">endl</span> &lt;&lt; d &lt;&lt; <span class="built_in">endl</span> &lt;&lt; c &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ostrStream.str();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出<br>Avatar<br>Titanic<br>123<br>5.2<br>K</p>
<h5 id="getline方法-保留空格"><a href="#getline方法-保留空格" class="headerlink" title="getline方法(保留空格)"></a>getline方法(保留空格)</h5><p>函数原型</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">istream&amp; <span class="title">getline</span> <span class="params">(istream&amp;  is, <span class="built_in">string</span>&amp; str)</span></span>;</span><br></pre></td></tr></table></figure>

<p>有时，我们希望能够保留字符串中的空格，这时需要使用getline方法。getline函数的参数是一个输入流和一个string对象，返回值为流参数。</p>
<p>函数从给定的输入流中读入内容，直到遇到换行符为止（注意换行符也被读进来了），然后把所读的内容存入到那个string对象中去（注意不存换行符）。getline只要一遇到换行符就结束读取操作并返回结果，哪怕输入的一开始就是换行符也是如此。如果输入真的一开始就是换行符，那么所得的结果是个空string。</p>
<h3 id="遍历访问"><a href="#遍历访问" class="headerlink" title="遍历访问"></a>遍历访问</h3><p>我们经常需要单独处理string对象中的字符，比如检查一个string对象是否包含空白，或者把string对象中的字母改成小写，再或者查看某个特定的字符是否出现等。</p>
<p>因此，这将涉及到两个关键问题：</p>
<ul>
<li>1 获取字符串中的每个字符</li>
<li>2 判定字符的特性</li>
</ul>
<p>对于第二个问题，cctype头文件中定义一系列函数帮助我们判定字符特性，如是否为数字，是否大写或小写</p>
<div aglin="center"><img src="/images/UVAOJ2/cctype.png"></div>

<p>对于第一个问题，我将从以下三方面进行讨论：</p>
<ul>
<li>1 全序列遍历</li>
<li>2 遍历全序列并修改字符</li>
<li>3 随机访问</li>
</ul>
<h4 id="全序列遍历"><a href="#全序列遍历" class="headerlink" title="全序列遍历"></a>全序列遍历</h4><p>使用C++11新标准提供的一种语句：范围for（range for）语句。这种语句<strong>遍历给定序列中的每个元素</strong>并<strong>对序列中的每个值执行某种操作</strong>，其语法形式是：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(declaration: expression)</span><br><span class="line">    statement</span><br></pre></td></tr></table></figure>

<p>其中，expression 部分是一个对象，用于表示一个序列。declaration 部分负责定义一个变量，该变量将被用于访问序列中的基础元素。<strong>每次迭代</strong>，declaration部分的变量会<strong>被初始化为expression部分的下一个元素值</strong>。</p>
<p>示例</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(<span class="string">"HelloWorld"</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> c : s)</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; c &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>

<p>此例中，通过使用auto关键字让编译器来决定变量c的类型，这里c的类型是char。每次迭代，str的下一个字符被拷贝给c。</p>
<h4 id="遍历全序列并修改字符"><a href="#遍历全序列并修改字符" class="headerlink" title="遍历全序列并修改字符"></a>遍历全序列并修改字符</h4><p>如果想要改变string对象中字符的值，必须把循环变量定义成引用类型。当使用引用作为循环控制变量时，这个变量实际上<strong>被依次绑定到了序列的每个元素</strong>上。使用这个引用，我们就能改变它绑定的字符。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(<span class="string">"HelloWorld"</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;c : s)</span><br><span class="line">    c = <span class="built_in">toupper</span>(c);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>

<h4 id="随机访问"><a href="#随机访问" class="headerlink" title="随机访问"></a>随机访问</h4><p>要想访问string对象中的单个字符有两种方式：一种是使用下标，另外一种是使用迭代器。这里我仅介绍通过下标访问字符串</p>
<p>下标运算符（[]）接收的输入参数是string:：size type类型的值，这个参数表示要访问的字符的位置；返回值是该位置上字符的引用。<br>string对象的下标从0计起。如果string对象s至少包含两个字符，则s[0]是第1个字符、s[1]是第2个字符、s[s.size()-1]是最后一个字符。</p>
<p><em>只要字符串不是常量，就能为下标运算符返回的字符赋新值。</em></p>
<h5 id="越界检查"><a href="#越界检查" class="headerlink" title="越界检查"></a>越界检查</h5><p>使用下标进行随机访问，需要对下标进行检查，使其限制在0~size()-1 的范围内，标准库不会检查下标是否合法，因此一旦下标超出范围，可能会出现不可预知的结果！</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!s.empty())</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; s[<span class="number">0</span>] &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//使用下标需要判断字符串是否为空</span></span><br></pre></td></tr></table></figure>

<p>关于字符串基础知识就介绍到这里啦！在入门经典第三章之字符串（下），我会以UVAOJ中的字符串题目为例，具体应用字符串及定义在其上的运算~</p>
<p>关于基础字符串的示例代码，可以进入我的github<a href="https://github.com/VealM/UVaOJ" target="_blank" rel="noopener">仓库</a>查看~<br>参考链接：</p>
<p><a href="http://www.cplusplus.com/reference/string/string/insert/?kw=string%3A%3Ainsert" target="_blank" rel="noopener">官方文档 cpluscplus</a><br><a href="https://www.amazon.com/Primer-5th-Stanley-B-Lippman/dp/0321714113" target="_blank" rel="noopener">c++primer第五版</a><br><a href="https://blog.csdn.net/longzaitianya1989/article/details/52909786" target="_blank" rel="noopener">c语言中文网</a></p>
]]></content>
      <categories>
        <category>算法竞赛</category>
        <category>cpp基础</category>
      </categories>
      <tags>
        <tag>cpp字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>入门经典第一、二章</title>
    <url>/2020/07/27/UVAOJ1/</url>
    <content><![CDATA[<p>第一、二章内容较为简单，主要涉及到以下几点：</p>
<ul>
<li>数据类型(ing longlong double float)的取值范围</li>
<li>数据的格式化输出</li>
<li>竞赛中文件输入输出规范</li>
</ul>
<a id="more"></a>

<h2 id="数据类型的取值范围"><a href="#数据类型的取值范围" class="headerlink" title="数据类型的取值范围"></a>数据类型的取值范围</h2><p>了解各类数据类型的取值范围对于竞赛题是至关重要的，因为可能对于某些样例可能涉及到溢出问题。</p>
<table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">位</th>
<th align="center">范围</th>
</tr>
</thead>
<tbody><tr>
<td align="center">char</td>
<td align="center">1个字节</td>
<td align="center">-128 ~ 127 (2^7-1)</td>
</tr>
<tr>
<td align="center">int</td>
<td align="center">4个字节</td>
<td align="center">-2^31 ~ 2^31-1 <strong>(近似-2*10^9 ~ 2*10^9)</strong></td>
</tr>
<tr>
<td align="center">long long</td>
<td align="center">8个字节</td>
<td align="center">-2^63 ~ 2^63-1 <strong>(近似-10^19 ~ 10^19)</strong></td>
</tr>
<tr>
<td align="center">float</td>
<td align="center">4个字节</td>
<td align="center">7位有效数字</td>
</tr>
<tr>
<td align="center">double</td>
<td align="center">8个字节</td>
<td align="center">8位有效数字</td>
</tr>
</tbody></table>
<p>需要注意的是，同种数据类型间的运算，所得计算结果同样依然为该数据类型，因此在选择数据类型的时候，不仅要考虑输入变量，同时也要考虑<strong>计算过程中是否会溢出</strong>！</p>
<p>试着考虑以下错误例子</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">655360</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> b = a*a;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码的执行结果如下</p>
<div align="center"><img src="/images/UVAOJ1/test.png" width=50%></div>

<p>我们发现，655360^2在整数范围内的计算溢出了，最终计算结果为0。因此，如果想得到正确的计算结果，我们应该修正为<em>long long a = 655360</em>。</p>
<h2 id="数据输出格式"><a href="#数据输出格式" class="headerlink" title="数据输出格式"></a>数据输出格式</h2><p>刘汝佳老师在书中介绍了浮点型数据的小数格式输出，默认输出六位，在C语言中进行如下的格式化输出</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> a = <span class="number">0.043567</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.5lf"</span>,a); <span class="comment">//保留5位输出</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们介绍cpp中用于小数格式化输出的流操纵算子，需要包含头文件iomanip。流操作算子的具体介绍可参考<a href="http://c.biancheng.net/view/275.html" target="_blank" rel="noopener">C语言中文网</a>，这里仅列出常用流操纵算子：</p>
<table>
<thead>
<tr>
<th align="center">流操纵算子</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">fixed</td>
<td align="center">以普通小数形式输出浮点数</td>
</tr>
<tr>
<td align="center">scientific</td>
<td align="center">以科学计数法形式输出浮点数</td>
</tr>
<tr>
<td align="center">setw(w)</td>
<td align="center">指定输出宽度为 w 个字符，或输人字符串时读入 w 个字符</td>
</tr>
<tr>
<td align="center">setfill(c)</td>
<td align="center">在指定输出宽度的情况下，输出的宽度不足时用字符 c 填充（默认情况是用空格填充）</td>
</tr>
<tr>
<td align="center">setprecision(n)</td>
<td align="center">设置输出浮点数的精度为 n。</td>
</tr>
<tr>
<td align="center"><em>注: setprecision(n),在使用非 fixed 且非 scientific 方式输出的情况下，n 即为有效数字最多的位数，如果有效数字位数超过 n，则小数部分四舍五入;在使用 fixed 方式和 scientific 方式输出的情况下，n 是小数点后面应保留的位数。</em></td>
<td align="center"></td>
</tr>
</tbody></table>
<p>对于具有互斥性的输出格式，需要使用resetiosflags函数进行取消，否则可能设置的输出格式未能正确生效。</p>
<p>以下为浮点数输出示例</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> a = <span class="number">0.043567</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; fixed &lt;&lt; setprecision(<span class="number">5</span>) &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 输出 0.04357</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; resetiosflags(ios::fixed) &lt;&lt; scientific &lt;&lt; setprecision(<span class="number">6</span>) &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 输出 4.356700e-02</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; resetiosflags(ios::scientific) &lt;&lt; setprecision(<span class="number">5</span>) &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//输出0.043567</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>不妨看道书上的例题</p>
<div align="center"><img src="/images/UVAOJ1/subseq.png" width=50%></div>

<p>涉及考点：</p>
<ul>
<li>运算溢出</li>
<li>输出格式</li>
</ul>
<p>首先看个标准错误解法…</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fin cin</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fout cout</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//ifstream fin("subseq.in");</span></span><br><span class="line">    <span class="comment">//ofstream fout("subseq.out");</span></span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="keyword">while</span> (fin &gt;&gt; n &gt;&gt; m)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span> || m == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">double</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = m; i &gt;= n; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> prt = i*i;</span><br><span class="line">            <span class="keyword">double</span> s = <span class="number">1.0</span> / prt;</span><br><span class="line">            res += s;</span><br><span class="line">        &#125;</span><br><span class="line">        fout &lt;&lt; fixed &lt;&lt; setprecision(<span class="number">5</span>) &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于第一个样例，该程序是能够正常通过的；但第二个样例，输出为inf；<br>相信结合之前的知识点，一定能看出这里是 <em>long long prt =i*i</em> 当i=655360时运算溢出，使得prt=0，进而导致计算s时出现<em>1.0/0</em>的情况，系统输出inf。<br>此处我们有两种改法<br>方法1： 将int i改为long long i，避免运算溢出<br>方法2:  使用pow函数进行i的幂方运算，double的精度较高同样能避免溢出。</p>
<h2 id="文件输入输出规范"><a href="#文件输入输出规范" class="headerlink" title="文件输入输出规范"></a>文件输入输出规范</h2><p>主要方案分两种：</p>
<ol>
<li>输入输出重定向</li>
<li>文件流输出</li>
</ol>
<p>原书中以c对两种方案进行介绍，这里以cpp的形式对两种方案进行介绍，以最简单的A+B题为情境。</p>
<h3 id="输入输出重定向"><a href="#输入输出重定向" class="headerlink" title="输入输出重定向"></a>输入输出重定向</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"aplusb.in"</span>,<span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"aplusb.out"</span>,<span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> a, b;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a+b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果取消重定向，则可以注释首行 #define LOCAL</p>
<h3 id="文件流输入输出"><a href="#文件流输入输出" class="headerlink" title="文件流输入输出"></a>文件流输入输出</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="comment">//#define fin cin</span></span><br><span class="line"><span class="comment">//#define fout cout</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">ifstream <span class="title">fin</span><span class="params">(<span class="string">"subseq.in"</span>)</span></span>; <span class="comment">//文件流声明</span></span><br><span class="line">    <span class="function">ofstream <span class="title">fout</span><span class="params">(<span class="string">"subseq.out"</span>)</span></span>; <span class="comment">// 文件流声明</span></span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    fin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    fout &lt;&lt; a+b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果取消文件流输入输出，则可在文件头部添加定义信息 <em>#define fin cin</em> 与 <em>#define fout cout</em>，并注释文件流声明即可。</p>
<h2 id="趣题共赏"><a href="#趣题共赏" class="headerlink" title="趣题共赏"></a>趣题共赏</h2><p>下面看道有趣的练习题</p>
<div align="center"><img src="/images/UVAOJ1/permu.png"></div>

<p>这道题的主要考点在于：</p>
<ul>
<li>1 确定枚举范围（事实上，我们只需要对a进行枚举，并且范围可限制在123-333）</li>
<li>2 此时，我们约束条件未能达到排列要求，因此需要添加约束判断。在这里，我采用了加和与乘积共同确定排列解，事实上，这是能够达到约束要求。如果需要严谨的数学推导，我想应该是从乘积出发，对其进行质因子分解，通过排列组合验证，只有1-9的要求才能达到加和条件</li>
</ul>
<p>以下是解法代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getDigit</span><span class="params">(<span class="keyword">int</span> q, <span class="keyword">int</span>&amp; mul)</span></span>&#123;</span><br><span class="line">    <span class="comment">//return q/100 + (q/10)%10 + q%10;</span></span><br><span class="line">    <span class="keyword">int</span> hi = q/<span class="number">100</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = (q/<span class="number">10</span>) % <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> lo = q % <span class="number">10</span>;</span><br><span class="line">    mul = mul * hi * mid * lo;</span><br><span class="line">    <span class="keyword">return</span> hi + mid + lo;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s ,m, l;</span><br><span class="line">    <span class="keyword">for</span> ( s = <span class="number">123</span>; s &lt; <span class="number">333</span>; s++)</span><br><span class="line">    &#123;</span><br><span class="line">        m = s*<span class="number">2</span>;</span><br><span class="line">        l = s*<span class="number">3</span>;</span><br><span class="line">        <span class="keyword">int</span> multi = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> sum = getDigit(s,multi) + getDigit(m,multi) + getDigit(l,multi);</span><br><span class="line">        <span class="keyword">int</span> check = <span class="number">2</span>*<span class="number">3</span>*<span class="number">4</span>*<span class="number">5</span>*<span class="number">6</span>*<span class="number">7</span>*<span class="number">8</span>*<span class="number">9</span>;</span><br><span class="line">        <span class="keyword">if</span> (sum == <span class="number">45</span> &amp;&amp; multi == check)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="string">" "</span> &lt;&lt; m  &lt;&lt; <span class="string">" "</span> &lt;&lt; l &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>正确输出</p>
<p>192 384 576<br>219 438 657<br>273 546 819<br>327 654 981</p>
]]></content>
      <categories>
        <category>算法竞赛</category>
        <category>cpp基础</category>
      </categories>
      <tags>
        <tag>基本数据类型</tag>
      </tags>
  </entry>
  <entry>
    <title>暑期刷题之旅</title>
    <url>/2020/07/27/UVaOJ0/</url>
    <content><![CDATA[<p>近期，老师和朋友建议暑期刷LeetCode以增加个人竞争力，关于未来规划，与其想得过多，不如先准备好议价的筹码。</p>
<p>但毕竟是个非科班选手，本科选修的数据结构侧重介绍线性表、树、图的原理，尽管董老师课讲得非常好，但并不是个刷题班（惭愧，好像学得也快忘完了）。作为一个小白，估计刷LeetCode，大约就一直停留于Easy模式，难以前进…</p>
<a id="more"></a>

<p>认清自己不想麻烦别人、也不想一劳永逸地报班的现实之后，我在电脑上打开吃灰的电子书文件夹，目前选择刘汝佳老师的《算法竞赛入门经典》为主，Sedgewick的《算法(C实现)》为辅，理由如下：</p>
<ol>
<li>《算法竞赛入门经典》题例较多，可以基本认为是分类题集，相比于随机刷题更具系统性</li>
<li>《入门经典》相比于《算法》《算法导论》薄很多，给了我“开学前能刷完一半”的希望</li>
<li>《入门经典》的缺憾在于对数据结构的实现介绍较少，而我也忘得差不多了，所以用《算法(C实现)》补充些理论知识</li>
</ol>
<p>总之，准备活动大概就是这样啦！flag就不立了，总之希望自己能踏实地刷好《入门经典》，经受住做题时“我怎么这么傻”的心理打击，在思考中提升智商与逻辑能力（</p>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>刘汝佳</tag>
        <tag>计划</tag>
      </tags>
  </entry>
  <entry>
    <title>powershell美化</title>
    <url>/2020/07/25/beautyposh/</url>
    <content><![CDATA[<p>早上睁眼就收到阿里云服务器已过期的短信，但我都习惯了vscode + remotessh在linux上写各种HelloWorld了…主要爽在命令行的高效操作（rm -rf /*）和包管理，那么试试在win10下进行折腾~<br>主要思路为：<br>利用<a href="https://github.com/JanDeDobbeleer/oh-my-posh" target="_blank" rel="noopener">oh-my-posh</a>对powershell进行强化（命令行）<br>使用<a href="https://scoop.sh/" target="_blank" rel="noopener">scoop</a>进行包管理</p>
<a id="more"></a>

<h2 id="powershell篇"><a href="#powershell篇" class="headerlink" title="powershell篇"></a>powershell篇</h2><p>这里列一些必要的打卡及查看终端属性的方式。<br><strong>启动powershell</strong>：<br>win + r</p>
<div align="center"><img src="/images/beautyposh/cmd.png"></div>
确定后打开powershell
<div align="center"><img src="/images/beautyposh/shell.png"></div>

<p><strong>查看基本属性</strong>：<br>右键打开属性</p>
<div align="center"><img src="/images/beautyposh/settings.png"></div>
查看字体等属性
<div align="center"><img src="/images/beautyposh/font.png"></div>

<h3 id="安装更纱黑体"><a href="#安装更纱黑体" class="headerlink" title="安装更纱黑体"></a>安装更纱黑体</h3><p>powershell中的默认字体是新宋体，我们安装<a href="https://github.com/be5invis/Sarasa-Gothic" target="_blank" rel="noopener">更纱黑体</a>以解决中英文兼容问题</p>
<h4 id="从微软应用商店安装"><a href="#从微软应用商店安装" class="headerlink" title="从微软应用商店安装"></a>从微软应用商店安装</h4><p>点击<a href="https://www.microsoft.com/zh-cn/p/%E6%9B%B4%E7%BA%B1%E9%BB%91%E4%BD%93/9mw0m424ncz7?activetab=pivot:overviewtab" target="_blank" rel="noopener">更纱黑体页面</a>，选择安装进入到微软商店下载相关包即可。</p>
<h5 id="查看安装是否生效"><a href="#查看安装是否生效" class="headerlink" title="查看安装是否生效"></a>查看安装是否生效</h5><p>查看powershell字体属性，如正常安装，则可以看到更纱黑体系列字体。</p>
<div align="center"><img src="/images/beautyposh/font.png"></div>

<h3 id="调整配色"><a href="#调整配色" class="headerlink" title="调整配色"></a>调整配色</h3><h4 id="原生powershell"><a href="#原生powershell" class="headerlink" title="原生powershell"></a>原生powershell</h4><h5 id="前端大佬专用"><a href="#前端大佬专用" class="headerlink" title="前端大佬专用"></a>前端大佬专用</h5><p>原生powershell启动快，但配色方案也有限，对自己审美有自信，进入属性依次调整各项<br>总之我对自己的审美失去了自信…</p>
<div align="center"><img src="/images/beautyposh/myposh.png"></div>
<div align="center"><font size=2>powershell配色效果图</font></div>

<h5 id="使用ColorTool"><a href="#使用ColorTool" class="headerlink" title="使用ColorTool"></a>使用ColorTool</h5><p>当然还是使用配色模板更香啦<br>使用微软推出的<a href="https://github.com/microsoft/terminal/releases/tag/1904.29002" target="_blank" rel="noopener">ColorTool</a><br>解压后出现ColorTool.exe文件，运行即可。出于方便考虑，我们将ColorTool加入环境变量<br>按从左至右参考如图步骤添加ColorTool.exe所在文件夹至系统变量PATH中，并保存生效</p>
<div align="center"><img src="/images/beautyposh/env.png"></div>
<div align="center"><font size=2>不知道怎么配置环境变量的自行百度</font></div>

<p>在终端中查看colortool自带默认模板<br><em>命令</em> color -s<br>(透明度导致短选项不太清晰呢…)</p>
<div align="center"><img src="/images/beautyposh/default.png"></div>


<p>使用colortool将他人模板应用于powershell</p>
<div align="center"><img src="/images/beautyposh/template.png"></div>

<p>模板文件类型是itermcolors，可以在这个<a href="https://iterm2colorschemes.com/" target="_blank" rel="noopener">网站</a>下载<br>（你可能需要科学上网才能访问…）<br>打开喜欢的模板链接，将该页面保存为*.itermcolors（不要以txt结尾！）即可~</p>
<div align="center"><img src="/images/beautyposh/love.png"></div>

<h4 id="Fluent-Terminal"><a href="#Fluent-Terminal" class="headerlink" title="Fluent Terminal"></a>Fluent Terminal</h4><p>Fluent Terminal是备受推荐的第三方终端，据说启动速度相当优异，但我试了下…感觉和原生速度差得还是蛮远的…</p>
<h5 id="下载Fluent-Terminal"><a href="#下载Fluent-Terminal" class="headerlink" title="下载Fluent Terminal"></a>下载Fluent Terminal</h5><p>从<a href="https://www.microsoft.com/zh-cn/p/fluent-terminal/9p2krlmfxf9t?rtc=1&activetab=pivot:overviewtab" target="_blank" rel="noopener">微软商店</a>中进行获取或者在其页面进行<a href="https://github.com/felixse/FluentTerminal" target="_blank" rel="noopener">手动安装</a></p>
<p>成功安装后打开页面如下（还是相当漂亮的~而且支持多标签页呀！）</p>
<div align="center"><img src="/images/beautyposh/fluent.png" width=50%></div>

<p>进入属性页，改变字体为等纱黑体</p>
<div align="center"><img src="/images/beautyposh/ffont.png" width=50%></div>

<p>选择喜欢的模板</p>
<div align="center"><img src="/images/beautyposh/ftemp.png" width=50%></div>

<p>除了loveplace和MyBash是我导入的模板，其余均为系统内置，其实ubuntu和homebrew就相当好看啦</p>
<h6 id="彩蛋"><a href="#彩蛋" class="headerlink" title="彩蛋"></a>彩蛋</h6><p>Fluent Terminal还支持ssh，不过对于我已经装了openssh的这种用户来说，意义不大啦</p>
<div align="center"><img src="/images/beautyposh/ssh.png" width=50%></div>

<h3 id="安装oh-my-posh"><a href="#安装oh-my-posh" class="headerlink" title="安装oh-my-posh"></a>安装oh-my-posh</h3><p>现在安装<a href="https://github.com/JanDeDobbeleer/oh-my-posh" target="_blank" rel="noopener">oh-my-posh</a>真的很容易！<br>为了确保安装成功，在设置中应用开发者模式如下</p>
<div align="center"><img src="/images/beautyposh/dev.png" width=50%></div>

<p>并启动管理员powershell进行安装：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Install-Module posh-git -Scope CurrentUser</span><br><span class="line">Install-Module oh-my-posh -Scope CurrentUser</span><br></pre></td></tr></table></figure>

<h4 id="创建配置文件"><a href="#创建配置文件" class="headerlink" title="创建配置文件"></a>创建配置文件</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 如果无配置文件 则创建</span></span><br><span class="line">if (!(Test-Path -Path $PROFILE )) &#123; New-Item -Type File -Path $PROFILE -Force &#125;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 记事本打开</span></span><br><span class="line">notepad $PROFILE</span><br></pre></td></tr></table></figure>

<p>在记事本中添加如下内容</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Import-Module posh-git </span><br><span class="line">Import-Module oh-my-posh </span><br><span class="line">Set-Theme Paradox # Paradox就是应用的主题 你也可以修改其他主题</span><br></pre></td></tr></table></figure>

<h4 id="应用oh-my-posh"><a href="#应用oh-my-posh" class="headerlink" title="应用oh-my-posh"></a>应用oh-my-posh</h4><p>为了能够成功应用，你需要进行授权</p>
<p>以管理员启动powershell</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">set-executionpolicy remotesigned</span><br></pre></td></tr></table></figure>

<p>然后再重新打开powershell，不出意外会成功生效</p>
<div align="center"><img src="/images/beautyposh/suc.png"></div>

<p>关于更多oh-my-posh主题及自定义主题介绍，可以参考<a href="https://sspai.com/post/52907" target="_blank" rel="noopener">少数派</a>这篇文章在配置文件里设置。</p>
<h3 id="在VSCode中应用oh-my-posh"><a href="#在VSCode中应用oh-my-posh" class="headerlink" title="在VSCode中应用oh-my-posh"></a>在VSCode中应用oh-my-posh</h3><p>如果直接打开VSCode，你会发现oh-my-posh主题的箭头不能正常显示，出现乱码。</p>
<p>其实是中英字体兼容的问题，在设置里，添加等纱黑体即可解决<br>（你一定要看蓝色部分）</p>
<div align="center"><img src="/images/beautyposh/vs.png"></div>

<p>不出意外的话，你也会看到美腻的内置终端</p>
<div align="center"><img src="/images/beautyposh/vsposh.png"></div>

<h2 id="包管理器-Scoop"><a href="#包管理器-Scoop" class="headerlink" title="包管理器 Scoop"></a>包管理器 Scoop</h2><p>其实我没有装Scoop，但我还是要大力推荐下，因为上述所说的oh-my-posh等都可以通过scoop来安装。</p>
<p>与debian下的apt、mac下的homebrew类似，scoop是windows下的包管理器，不过相比于chocolatey，它能够将应用隔离在ScoopApps中。</p>
<p>我吐槽下自己没法装Scoop的原因吧：</p>
<ol>
<li>Scoop是直接从官网下载的，如果不能高速科学上网，呵呵，自行体验下。<br>当然你也可以现装aria2嘿嘿，那样还是快一些的</li>
<li>默认安装在C盘用户目录下，有好处啊，比如省去配置环境变量的麻烦<br>但我就128G的SSD用来装系统盘…现在就剩30G了…平时只能软件装在500G的机械硬盘上…好了我也知道了为什么服务器全SSD盘装matlab好快，而我机械硬盘装了30min…</li>
</ol>
<p>（此处为废话：由此我得出结论了，如果你电脑是全SSD盘！那就不要分区！买个机械硬盘插在空仓位上存文件它不香么！）</p>
<p>以及，有钱有技术的大佬能不能搭个scoop国内镜像呀QAQ</p>
<p>参考博客</p>
<p><a href="https://sspai.com/post/52907" target="_blank" rel="noopener">少数派</a></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>玩</tag>
      </tags>
  </entry>
  <entry>
    <title>jupyterlab激活虚拟环境</title>
    <url>/2020/07/07/labjupyter/</url>
    <content><![CDATA[<p>对于大型超算平台，通常采用jupyterlab作为用户接口，我们可以在web端创建、运行python程序。</p>
<a id="more"></a>

<div align="center"><img src="/images/labjupyter/lab.png",width="50%"></div>
<div align="center"><font size=2>jupyterlab示例图(图源lzuhpc)</font></div>

<p>为了给应用创建一套“隔离”的python环境（如在不同的环境中创建django网站、使用tensorflow进行数据分析），我们需要创建虚拟环境。我们以conda为例，在超算平台上创建虚拟环境安装tensorflow并在jupyterlab中使用它。</p>
<h3 id="安装ananconda及环境变量配置"><a href="#安装ananconda及环境变量配置" class="headerlink" title="安装ananconda及环境变量配置"></a>安装ananconda及环境变量配置</h3><p>详情见<a href="https://vealm.gitee.io/2020/02/04/envset-1/">该博文</a>，本处略</p>
<h3 id="创建tensorflow环境及安装"><a href="#创建tensorflow环境及安装" class="headerlink" title="创建tensorflow环境及安装"></a>创建tensorflow环境及安装</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">conda create --name tf2 python=3.7</span><br></pre></td></tr></table></figure>

<p>创建tf2虚拟环境，指定python版本为3.7</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">conda activate tf2 # 激活tf2环境</span><br><span class="line">pip install tensorflow # 通过pip安装tensorflow</span><br></pre></td></tr></table></figure>

<p>从tensorflow2起，不再对gpu与cpu版本进行区分，因此只需要直接安装即可，如果对版本敏感，可</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip install tensorflow-cpu</span><br></pre></td></tr></table></figure>

<p>如果一切顺利，可在终端正常运行以下代码</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">conda acitvate tf2</span><br><span class="line">python</span><br><span class="line">Python 3.7.7 (default, May  7 2020, 21:25:33) </span><br><span class="line">[GCC 7.3.0] :: Anaconda, Inc. on linux</span><br><span class="line">Type "help", "copyright", "credits" or "license" for more information.</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; import tensorflow as tf</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; A = tf.constant([[1, 2], [3, 4]]) </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 可能伴有一些信息输出 可暂时无视</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; B = tf.constant([[5, 6], [7, 8]])</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; C = tf.matmul(A, B)</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; <span class="built_in">print</span>(C)</span></span><br><span class="line">tf.Tensor(</span><br><span class="line">[[19 22]</span><br><span class="line"> [43 50]], shape=(2, 2), dtype=int32)</span><br></pre></td></tr></table></figure>

<p>如果C能正常输出，则说明已安装成功</p>
<h3 id="在jupyterlab中使用tensorflow"><a href="#在jupyterlab中使用tensorflow" class="headerlink" title="在jupyterlab中使用tensorflow"></a>在jupyterlab中使用tensorflow</h3><p>lzuhpc提供了jupyterlab的用户接口，方便代码调试，但其默认是base环境，因此我们需要安装相关包以激活tf2虚拟环境</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">conda activate tf2 # 激活tf2虚拟环境</span><br><span class="line">conda install ipykernel</span><br><span class="line">ipython install --user --name tf2 # ipython安装tf2虚拟环境</span><br></pre></td></tr></table></figure>

<p>此时进入jupyterlab，可以看到创建新文件中多了tf2，点击进行新文件创建即可使用tensorflow。</p>
<div align="center"><img src="/images/labjupyter/lab.png",width="50%"></div>
<div align="center"><font size=2>jupyterlab示例图(图源lzuhpc)</font></div>

<br>

<div align="center"><img src="/images/labjupyter/tf2.png",width="50%"></div>
<div align="center"><font size=2>tf2笔记本示意图(图源lzuhpc)</font></div>]]></content>
      <tags>
        <tag>hpccluster</tag>
        <tag>jupyter</tag>
      </tags>
  </entry>
  <entry>
    <title>访问互联网指南</title>
    <url>/2020/03/12/www/</url>
    <content><![CDATA[<p>本篇文章提供通过<a href="https://github.com/XX-net/XX-Net" target="_blank" rel="noopener">XX-net</a>访问互联网的方式，尤其适用于Ipv6用户(高校、互联网大厂均分配ipv6)。</p>
<p>本篇仅提供ipv4-win10-chrome浏览器(最常见)接入XX-net方式以及常见问题的分析。</p>
<a id="more"></a>

<h2 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h2><p>首先我将对整个流程进行解读(瞎掰)，把握主体思路有利于解决半路杀出的bug。</p>
<p>XX-net的前身是GoAgent代理，采用python语言编写。与熟知的SS/SSR/V2arrayN代理相似，其也是通过中转海外服务器进行数据传输，但也有不同之处——XX-net接入谷歌数据中心利用云应用进行数据传输，因此它理论上是免费的。</p>
<p>利用以下数据传输图描述SS与XX-net数据传输路径:</p>
<p>SS客户端 &lt;=Socks5==&gt;(SSlocal&lt;=密文=&gt;)  SS服务端  —&gt;海外目标主机(谷歌)</p>
<p>XX-net客户端 &lt;==&gt; 全球谷歌数据中心 &lt;–&gt; 谷歌云GAE(需要通过开发者账户申请，XX-net提供公共AppId)</p>
<p>由此我们可以看出，XX-net通过扫描可用全球谷歌数据中心ip及接入白嫖谷歌云app实现免费数据传输(是呀不用租海外服务器了)。但是相比SS缺少加密机制，网络报文中会暴露数据隐私，但仅作科研使用问题不大。</p>
<p>根据我的体验来说，相比于SSR，XX-net的麻烦在于</p>
<ul>
<li><p>1 扫描可用的谷歌数据中心ip（出于种种原因，谷歌并没有被完全封锁，但活的ip也很少了）<br>以及遇到很奇怪的事，我分别开通过GAE香港和GAE美国，对于GAE香港检测ip通过率高于GAE美国(切换到美国可使用ip数会一直降)，或许可用ip数的检测是以两跳结果(ip中心–&gt;GAE)作为判断？</p>
</li>
<li><p>2 申请私用谷歌云app。尽管XX-net提供公用ip，但是用的人数过多因此限制仅浏览网页，禁止观看视频或下载。</p>
</li>
<li><p>3 对移动端支持不好。爱折腾如我都懒得折腾了…但你可以梅林路由器跑全局！</p>
</li>
</ul>
<p>以下部分在叙述基本使用方法的同时会兼顾以上三个难点的分析。</p>
<h2 id="安装XX-net"><a href="#安装XX-net" class="headerlink" title="安装XX-net"></a>安装XX-net</h2><ul>
<li><p>1 认准github地址，下载对应版本<a href="https://github.com/XX-net/XX-Net/blob/master/code/default/download.md" target="_blank" rel="noopener">XX-net</a></p>
</li>
<li><p>2 解压后点击 start.vbs进行安装。如弹出是否信任，是否授权，一律同意。</p>
</li>
<li><p>3 此时chrome浏览器将弹出localhost:8085要求进行相关配置。同时在电脑侧边栏将看到XX-net运行标志，右键修改代理方式为全局PAC智能代理。</p>
</li>
</ul>
<p>插曲: 我也试了浏览器代理方式，但似乎…效果不太行…所以我感觉修改为全局PAC智能代理就可以啦。项目作者提供的两种方法二选一即可，这里即为PAC代理方法</p>
<p><a href="https://github.com/XX-net/XX-Net/wiki/%E4%BD%BF%E7%94%A8Chrome%E6%B5%8F%E8%A7%88%E5%99%A8" target="_blank" rel="noopener">官方方法</a></p>
<p>注意，如果你的chrome浏览器过高，可能是不支持拖入crx文件安装拓展的。</p>
<h2 id="测试能否通过公共id访问互联网"><a href="#测试能否通过公共id访问互联网" class="headerlink" title="测试能否通过公共id访问互联网"></a>测试能否通过公共id访问互联网</h2><p>以上仅完成客户端安装，由于客户端内自带公共id，因此根据原理分析可知，此时需要扫描可用谷歌数据中心ip。</p>
<p>注意到作者的哭诉</p>
<p><em>由于封锁严重，软件自带IP已经被封杀殆尽。因此需要数分钟到数小时的初始化IP扫描，方能正常运行。</em></p>
<p>在8085端口的配置页我们可以看到状态:</p>
<p><img src="https://i.loli.net/2020/03/12/kKc7umHX5FoONlS.png" alt="pic1.png"></p>
<p>对于刚安装完XX-net的情况下，通常你并不会那么幸运看到这行蓝字，更多的是</p>
<p><em>尚未建立连接</em><br><em>建议开启ipv6或XX-Tunel</em><br><em>浏览器配置有问题</em></p>
<p>如果是3，请检查浏览器代理设置是否为OK，如果不是，重启XX-net客户端。如果重启失败，参考<a href="https://github.com/XX-net/XX-Net/wiki/How-to-get-start-error-log" target="_blank" rel="noopener">这里</a></p>
<p>如果是1或2，此时检查有效ip数是否为0以及连接池是否为0:0:0。如果是，说明暂时未扫描到可用的谷歌数据中心ip。</p>
<p>如何解决？</p>
<ul>
<li>1 增大扫描强度。按如下参数进行设置</li>
</ul>
<p><img src="https://i.loli.net/2020/03/12/oPw46SWHkaugRZG.png" alt="pic2.png"><br><img src="https://i.loli.net/2020/03/12/i2CKNbjkFDXsynV.png" alt="pic3.png"></p>
<p>记得修改后提交</p>
<ul>
<li>2 查看扫描日志 是否正在扫描，如作者所言，初始化扫描需要数分钟到小时，耐心等待。</li>
</ul>
<p><img src="https://i.loli.net/2020/03/12/yNY1VxauzismM4e.png" alt="pic4.png"></p>
<p>嗯，我能用的ip背后有多少time out的ip牺牲了。</p>
<p>所以强烈ipv6用户开启ipv6服务，在设置页也进行详尽介绍。但超出本文范围(目前没得ipv6用啊)相信我，一旦开启ipv6，扫描ip数瞬间上百！</p>
<p>以及理论上，不心疼电费可以把电脑开机联网让它扫描个几天几夜，这样你就会拥有很多可用ip！</p>
<ul>
<li>3 如果还是未连接…</li>
</ul>
<p>可以联系获取可用ip…不过作为ipv6用户能不和可怜的ipv4用户抢ip了么呜呜呜。</p>
<p>当你查看状态，出现和我一致的蓝字，那么恭喜你，可成功访问真正的互联网了！</p>
<h2 id="部署私有AppId"><a href="#部署私有AppId" class="headerlink" title="部署私有AppId"></a>部署私有AppId</h2><p>此步可选，如果用gmail账号且不怕麻烦，建议这样做。由于AppId每天限制流量1G且个人gmail账号app申请受限，假如你是我的密友且计算机接触不多，我会部署好app并把个人id给你用，直接进入<strong>录入AppId</strong>。(虽然我喜欢研究技术，但真正的收获是理清系统思路而不是给别人当24小时客服吧，我又没对谁收费过。)</p>
<p>为了减缓公共资源的使用，建议申请私有AppId，也即你的谷歌云应用。申请方式如下</p>
<ul>
<li>1 注册谷歌gmail账号</li>
</ul>
<p>注册gmail账号需要海外手机号接收短信，欢迎在海外留学的同学帮忙接收注册验证码，不会对你造成负面影响，作为答谢在网络可用情形下为你部署app。</p>
<ul>
<li><p>2 用gmail账号登录谷歌云申请私人AppId</p>
<ul>
<li><p>1 创建你的云应用<br>  进入<a href="https://console.cloud.google.com/start" target="_blank" rel="noopener">网页</a><br>  点击选择项目，然后点击创建项目<br>  <img src="https://cloud.githubusercontent.com/assets/19320102/26750556/af503ee2-4858-11e7-811b-30367691d912.png" alt="avatar"><br>  <img src="https://cloud.githubusercontent.com/assets/19320102/26750550/6abaaed4-4858-11e7-8386-e07f0391325f.png" alt="avatar"></p>
<p>  输入project名称系统自动生成AppId(ProjectId),请不要填写个人信息相关，web ios android也请不要写。</p>
</li>
<li><p>2 设置AppID的App引擎</p>
<p>  访问APP引擎信息中心， <a href="https://console.cloud.google.com/appengine/start?project=你的项目id" target="_blank" rel="noopener">https://console.cloud.google.com/appengine/start?project=你的项目id</a></p>
<p>  选择地点默认us-central即可。(但有条件的建议选择asia-east2香港节点)</p>
<p>  默认项目语言即为python，无需修改。绑定信用卡(biling)为可选项，跳过即可。查看右上角创建状态，如成功 返回8085进行部署。</p>
<p>  同时热烈欢迎有条件的朋友绑信用卡，我想体验下谷歌赠送的一年期的云服务器…(不会像AWS自动续费，而且申请服务器后随时都可解绑吧)</p>
</li>
<li><p>3 部署AppId</p>
<p>  回到8085界面 进行部署<br><img src="https://i.loli.net/2020/03/12/vcUmYHMQIAVxGXe.png" alt="pic5.png"></p>
<p>输入2获取的AppId，点击开始部署，打开显示日志并密切监控。请允许浏览器弹出窗口，经过若干分钟的等待后会进入gmail授权界面，当出现部署成功后，则该AppId可用。</p>
<p>番外: 这里有个bug，就是初始扫描获得的ip延迟挺大的，导致gmail授权界面经常出现504错误。嗯…这时不要着急，根据我对日志的观察客户端会反复尝试直至登入。<br>所以我还在想，是否有种方式可以不通过XX-net而直接对app进行部署呢？(因为我有买稳梯子连入谷歌)这样就可以直接进入录入ID环节，无需过久等待。<br>我找到了，在接入稳梯子的情形下可使用脚本部署<br><a href="https://github.com/XX-net/XX-Net/tree/master/code/default/gae_proxy/server" target="_blank" rel="noopener">脚本部署</a></p>
</li>
</ul>
</li>
</ul>
<h2 id="录入AppId"><a href="#录入AppId" class="headerlink" title="录入AppId"></a>录入AppId</h2><p><img src="https://i.loli.net/2020/03/12/6FrN45azPjUQ3MC.png" alt="pic6.png"></p>
<p>公共Id只能浏览网页，不能下载，不能看视频。因此私有Id还是很有必要的。</p>
<p>在这里进行录入Id的配置，将已经成功部署的AppId填入就可以啦。当然啦，你也可以从好朋友那里获得已部署的AppId进行录入。经过若干分钟的等待，你就可以自由看视频啦！</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>请大家去github上支持下作者！<br>有钱的出钱，支持<a href="https://github.com/XX-net/XX-Net/wiki/X-Tunnel%E4%BB%8B%E7%BB%8D" target="_blank" rel="noopener">X-Tunnel</a> 年度会员15美元,月均10rmb不到<br>有账号的出账号，捐赠私有AppId作为公共Id<br>如果想感谢我也欢迎（</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Network</tag>
        <tag>XX-net</tag>
      </tags>
  </entry>
  <entry>
    <title>岁月过客</title>
    <url>/2020/03/09/grow/</url>
    <content><![CDATA[<h2 id="觉醒"><a href="#觉醒" class="headerlink" title="觉醒"></a>觉醒</h2><p>22岁，或许我终于有资格说，不后悔来到兰州。<br>19年底正值为院创焦头烂额之际，我和高中好友骚老师通电话，以他的风格自然是给我一顿商业吹捧 “你真是一点没变，还是和高中一样。本科在兰州委屈你了，能去更好的。” ，全然不顾我的否认三连。电话挂断后，我不禁沉思，如果说不后悔，那么需要何种理由以超越高考排名对大学的评判呢。</p>
<a id="more"></a>

<p>刚入兰大时，我仿佛脱缰的野马，彻底放飞自我，上课睡觉下课玩手机——分析语言不适应，高等代数套公式，就这样居然误打误撞进入萃英读基础数学。不，说误打误撞过于抬举自己，能进入萃英多亏蒙总与蔡老板的支持。面试前夜，我看着高代书上的符号知道明日无望，至今犹记得蔡老板的鼓励 “其实当时我高代也学得不好，直到学完泛函回头看才清晰，学妹推导实在看不懂，先背下来以后再慢慢琢磨”。我对着闪烁的信息愣了一会，放弃了退缩的想法，当时并未意识到，未来三年他也多次在我迷茫之时指明方向。</p>
<p>进入萃英后，我仿佛回到高中，以名校为目标不断奋进，评价标准也如此相似，只不过细化到四年的每一场考试，如履薄冰。可生活并不按励志剧情发展，大一基础羸弱导致我想当然地理解概念——这可能是学数学最大的禁忌吧。可放假看不进去专业课，那就补下C语言保证数值分析上机不挂科——拿着《算法竞赛指南》请教(折磨)hopeful，知道他有人眼debug的神力，自己却没啥长进。</p>
<p>这点似乎和高中一样，当时拿到超纲的难题，自己不会做便去问老师，如果老师也觉得难，似乎就可以说明我是好学生。我可能并不在意到底该独立解决问题，只是在意有没有人帮我解决，在意我是不是所谓好学生。做着重复的无用功，却依然自我感动，从没人点醒我。如今看来，高中未收获探索自然学科的满足，只是熟练工的自我陶醉。</p>
<p>于是尝试改变，至今仍无法确信是否勉强达到独立解决基础问题的及格线。在这漫长的过程中，感谢蔡老板、hopeful、lch、萌神、迪哥的出现，虽为大神却对渣渣保持耐心，更重要的是我了解到在问题定位与分析层面与他们的差距。如果以名次衡量，他们并非普世意义的优秀(蔡老板名次也高…)，但突破应试限制以解决问题考核，都是值得我追随的榜样~ 不后悔在兰州，是因为若在别处，或许我四年仍沉醉于光环与随波逐流的自我感动中吧。</p>
<p>每年放假归来，同学总约着去看望初高中老师。有时我在想，大学毕业会有人看望专业课老师吗，仅因百人大教室中的短暂学期情谊？但我想，如果有机会我会的，因为数院的他们确实是我目光所及思想境界最深的人，不负大学老师的称号。</p>
<p>大三上因数据结构与数院“杀手”董老师结缘，早在大一我就领教杀手给分的无情——78分的C++，和他扫过我弱鸡上机作业的无语。可杀手从不以刻板印象盖棺定论，对我这个萃英C++倒一，他并未劝退“啥基础都没有退课吧”，反而在路上和我闲谈“我觉得你如能研究生转到计算机会很好，但这个过程很难，你要努力啊”。交课设作业他笑着说，“东西放这就行，你不用给我演示程序了，你说能运行我相信”。除了解决问题本身，他更在意我是否彻底弄清概念，甚至设计实验让我亲自尝试了解二维数组与二重指针的区别。我看到新奇的技术文章分享给他，也会得到他的看法，虽是数院的“老资格”，董老师依然乐于接受新技术，与年轻人讨论，给他们机会去试错与思考。</p>
<p>时间跳到大三下，当我面临人生选择时，耿老师与刘老师给予我坚定的支持。我自知在他们看来，只不过是个乳臭未干的小孩，对未来只有幼稚中二的想法。但他们耐心倾听我的想法，认真地说 “我觉得你很有想法和主见，人应该有自己热爱的事，否则只是为了活着而活着”。我也曾就选题询问过他们的意见，“我觉得，关于选题，最好你有自己的想法，我愿意和你一起去实现。学生不该成为老师做项目的工具，我不愿把自己的想法强加给你”，刘老师和李老师如是说。在学生抱怨老师为什么不直接告诉我怎么做，却不知他们培养学生独立研究能力的苦心吧。</p>
<p>严谨负责的孙老师，关心学生的焦老师、徐老师，挖我去当“码农”的齐老师、田老师…老师们不仅教好专业课，也尽力培养学生成为独立思考的人，我想这或许就是大学的意义。在当下重SCI轻教学的大学教师评价体系之下，他们仍尽心于本科生教学，又何尝不是一种伟大。认识这些精神明亮的“大朋友”，是我四年来最有意义的事。他们的存在是我心中兰大能超过高考排名评判标准的理由。</p>
<h2 id="无痕"><a href="#无痕" class="headerlink" title="无痕"></a>无痕</h2><p>小时候，每年樱花初绽，我便开始掰手指算着3月的到来，和妈妈站在摆着琳琅满目的蛋糕模具的橱窗前挑选最中意的款式。上初高中以后有了“人际交往”的意识，便会在心中暗暗期待互送礼物的小伙伴今年还会记得么，以致有时会失落有时会欣喜收到“意外礼物”。现在想起来，或许初高中是我社交最丰富的时期了。</p>
<p>相比于别人口中的“大学生活”，我的大学生活几乎可用“清心寡欲”来形容，无奖无名朋友少。但所幸有一苇和高洁相伴，在写不出论文做不出题的时光中也能平添欢乐。并不似外界对文科生的刻板印象，她们思辨与发散能力俱佳，我们讨论独立写作的行文思路，忧心996程序员“工具人”命运…每年生日，懒散的我甚至不买蛋糕，默默等两个室友回来一起去吃饭庆祝我们在奔三的路上又迈出坚实的一步(哈哈，因为她们生日都在假期)。由于疫情今年仍未开学，但忆及室友每年都会备上蛋糕与礼物，仍然十分感动。</p>
<p>细细想来，朋友之中，每年生日有一人的礼物总不会缺席——初中以来的好闺蜜扬。自中考后，我们去了不同的高中，不同的大学，乃至不同的国家，想想送礼物都是很麻烦的事 —— 高中会托爸妈把礼物放在单位传达室，大学靠着万能淘宝表达心意，跨国后也要趁公共假期聚在一起。我虽是不期待回应的人，但这长达十年的友谊，以生日之名寄托牵挂，对我而言十分珍贵。</p>
<p>今年很巧合的是，扬和苑送我的礼物竟一致为MAC口红。或许MAC可以打个广告——爱闺蜜，就送她MAC，哈哈。或许好朋友希望我也努力变得精致一点~（今年是真的不用买口红了！）每个免于挂科的学渣背后都有个负责的学霸，苑就是我背后的闪光学霸——我们之间流传着她凭几乎满分的成绩综测突围的事迹。聪明认真的苑毫无学霸的高冷气，天真笑容带着几分羞涩。很幸运，未来我们也继续在同一座城寻找前进之光。</p>
<div align="center"><img src="https://i.loli.net/2020/03/09/QJUPfSXT5FohVBZ.jpg" width=50% /></div>
<div align="center"><font size=2>MAC 1号与2号</font></div>

<p>作为一个日益汉子化的宅女，感谢好朋友的不抛弃不放弃！收到大傻的礼物，我想在她心里我还是个精致可爱的女孩子~于考研纷杂的心思中还能记起我，祝语是即使毕业后不在同一个地方，在清晨也会挂念彼此。希望努力执着的她可以实现顺利上岸的梦想，已经很近了！</p>
<div align="center"><img src="https://i.loli.net/2020/03/09/aUJgZuGOjF2rxPl.jpg" width=70% /></div>
<div align="center"><font size = 2>精致女孩项链</font></div>


<p>大学以来，我摒弃初高中“人际交往”准则：有时看QQ的生日提醒，想到他人对我的帮助，便送个礼物借生日之名表达感谢，不再期待所谓回应——但凡是我心甘情愿，又何必期待回应？虽然我妈对我的行为表示不解，毕竟他们那个年代的人总是恪守“礼尚往来”，但也懒得管我。岁月无痕，高中的我或许也会惊诧于如今这想法吧。</p>
<h2 id="未来"><a href="#未来" class="headerlink" title="未来"></a>未来</h2><p>我想我会记得，第一次数据结构课，董老师一个个问大家选课原因时，在“有用” “计算机技能”中的答案中，我眨眨眼说，“好玩 有趣 我喜欢”。回答很酷，神似大神。可我是小白，或许是从小练国画和钢琴，对于枯燥的事情有耐性，看到cmd窗口弹出基础OJ题正确的结果就可以兴奋很久，所以回答“好玩”。</p>
<div align="center"><img src ="https://www.ghostmachinery.com/wp-content/uploads/2019/04/Learn-Piano.jpg" width=70%></div>
<div align="center"><font size = 2>偶尔练琴，图源网络</font></div>

<p>有时我很羡慕那些初高中就折腾Linux系统和网络的人，我并非没有学习的条件，甚至亲历从电话拨号 adsl再到光纤宽带，从台式机到笔记本的历程，或许缺的是爱折腾的好奇心与不怕错的勇气。</p>
<p>hopeful说，“我和你的区别就是我知道学的东西该怎么用”。后来我才渐渐意识到，计算机和机器、系统、运行环境、通信打交道，远非我认识的 “知道定理A用来做课后题”。极客们认识计算机从开发应用渗透测试开始，新青年从学习Python开始，而我却从听Linux系统慕课、在hpc上装软件和数学库开始…没被劝退(没把学校机子搞崩)大概得益于耐性好(365*7*24的网信办运维强)。</p>
<p>最后要特别致谢爸妈支持，尤其老爸那句 “老古董电脑尽可能尝试，最坏结果也就再买一台”(树莓派2G降价了！)。虽然他们也吐槽我 “上个大学别人拿奖到手软，你啥都没可羞”，但依然尊重我按自己的想法生活，寻求自己人生的意义。我为他俩骄傲！</p>
<p>愿往后余生，依然有探索山川江河、星辰大海的勇气与孩子般的好奇心，如高洁所言“所向披靡地向前走，直到成为你想成为的人”。</p>
]]></content>
      <categories>
        <category>日常</category>
      </categories>
      <tags>
        <tag>温情</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言二维数组内存操纵问题</title>
    <url>/2020/03/02/return-2d-array-in-c/</url>
    <content><![CDATA[<p>看到这个标题，就知道是某个睡过大一的学渣来补C指针的坑了。<br>怕问得太多惹大佬同学烦，于是卑微大学生求助C++老师(老师:哦？现在知道学习了？)，竟得到董老师的耐心解答~<br>在平时与他人的交流讨论中，如能指个方向我都十分感激；但只有老师，关心你是否真正弄清概念，董老师甚至设计实验让我去尝试分析运行结果。<br>能成为你们的学生，真幸运。</p>
<a id="more"></a>

<h2 id="C函数返回二维数组"><a href="#C函数返回二维数组" class="headerlink" title="C函数返回二维数组"></a>C函数返回二维数组</h2><p>起因是朋友遇到如下语法检查不通过</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span>** <span class="title">func_me</span><span class="params">(<span class="keyword">int</span> N)</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> Mat[<span class="number">3</span>][<span class="number">4</span>];</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> Mat <span class="comment">//返回类型不一致</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从语法字面上，确实不一致。Mat的类型是const double**，与函数返回值double**不一致。<br>于是朋友问，改成这样对吗？语法检查通过了</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span>** <span class="title">func_me</span><span class="params">(<span class="keyword">int</span> N)</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span>** Mat;</span><br><span class="line">    ... <span class="comment">//对Mat[i][j]赋值</span></span><br><span class="line">    <span class="keyword">return</span> Mat </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然几乎不写C，但考虑到C指针与数组是对内存进行操作的，因此如果没有预先进行分配，即使语法检查通过也会出现运行时的段错误(segmentation fault)。</p>
<p>我曾经对如何让c函数返回二维数组很感兴趣，所以自己动手写了代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>** <span class="title">matrix_me</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> row, <span class="keyword">const</span> <span class="keyword">int</span> col)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>** mat = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>*)*row);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++)</span><br><span class="line">        mat[i] = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*col);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; row; k++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j&lt;col; j++)</span><br><span class="line">            mat[k][j] = k+ j;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> mat;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> row = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> col = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">int</span> ** mat;</span><br><span class="line">    mat = matrix_me(row,col);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; j++)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d"</span>,mat[i][j]);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\t"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; row; i++)&#123;</span><br><span class="line">            <span class="built_in">free</span>(mat[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(mat);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在gcc 7.5.0 CentOs7平台上可以正常执行。<br>从matrix_me函数中可以看出我的内存分配思路：首先分配指向row个一维数组的二重指针。再对row个一维数组依次分配col个int内存。之后的使用方法则和使用普通二维数组一致。<br>在释放内存的时候也要小心，遵循<em>先生后灭</em>的规则。也即先释放一维数组的内存，然后释放二重指针的内存。</p>
<p>按说故事在此该结束了，无奈我实在是个爱折腾的人，上面这个代码对于c基础一般的小白来说实在头疼，回到最初朋友的代码:  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span>** <span class="title">func_me</span><span class="params">(<span class="keyword">int</span> N)</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> Mat[<span class="number">3</span>][<span class="number">4</span>];</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//return Mat //返回类型不一致</span></span><br><span class="line">    <span class="keyword">double</span>** p = (<span class="keyword">double</span> **)Mat;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果我增加以下两行呢，能否实现她的要求呢？</p>
<h2 id="二重指针与二维数组名"><a href="#二重指针与二维数组名" class="headerlink" title="二重指针与二维数组名"></a>二重指针与二维数组名</h2><p>考虑到我返回的是二重指针，看上去p是指向Mat的指针，Mat含有3个一维数组(3个一维指针)。因此我外部函数可写成如下形式对元素进行访问:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>** <span class="title">get_array</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> Mat[<span class="number">3</span>][<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j&lt;<span class="number">3</span>; j++)</span><br><span class="line">                Mat[i][j] = i+j;<span class="comment">//printf("%d",Mat[i][j]);</span></span><br><span class="line">    <span class="keyword">int</span> **p = (<span class="keyword">int</span>**)Mat;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> **p = get_array();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> *ar = *(p+i);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j&lt;<span class="number">3</span>; j++)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d \t"</span>,*(ar+j));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);   </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但不幸的是，执行后报错<br>Segmentation fault<br>一般这种错误多是内存访问越界，但很奇怪，Mat已经在get_array中分配内存可正常访问元素，而p不过是Mat首地址，换一种方式访问相同内存，为什么还会出现这个错误呢？<br>而使用p[i][j]等价方式类也是同样的段错误。<br>此处剧透：既然访问时能想到一维数组，为什么分配时不考虑将一维指针数组的数组名作为二维数组名呢？</p>
<h3 id="Mat的生存周期？"><a href="#Mat的生存周期？" class="headerlink" title="Mat的生存周期？"></a>Mat的生存周期？</h3><p>显然自己太菜了，于是跑去找朋友请教，于是我把需求叙述一遍<br><em>在matrix_me函数内分配二维数组a，并返回到主函数供外部访问</em><br>忽然我觉得有些不对，二维数组a的生命周期似乎在matrix_me执行结束后随之消失，因此无论如何访问都不对呀！<br>于是我做了个实验，干脆将matrix_me内的代码加入主函数内，使得Mat就在外部声明，看看这样能否得到正确结果。<br>然而结果依旧是<br>Segmentation Fault<br>看来生命周期也不能使程序正确执行，虽然它也可能导致段错误。</p>
<p>不过可能会有疑问，之前正常运行的代码不也是函数内部声明了二维数组么，主函数还是可以使用。但那时使用malloc，如销毁则使用free，否则默认到main执行完才销毁。</p>
<h3 id="指向数组的指针与指向指针的指针"><a href="#指向数组的指针与指向指针的指针" class="headerlink" title="指向数组的指针与指向指针的指针"></a>指向数组的指针与指向指针的指针</h3><p>标题就像绕口令？</p>
<p>百思不得其解的我决定求助C++老师，竟然得到老师的回复：</p>
<p><em>Mat是指向数组的指针，而p是指向指针的指针，不做强制转换赋值，编译器会提示清晰的错误信息</em></p>
<p>由于我用gcc编译时未加-Wall参数，所以没收到错误信息。(今天也是被编译器嘲讽的一天呢)那么看来这个问题不难解决，伪代码思路如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> ** <span class="title">matrix_me</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> row, <span class="keyword">const</span> <span class="keyword">int</span> col)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> MAT[row][col];</span><br><span class="line">    <span class="comment">//MAT相关操作</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>* p[row];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i &lt; row; i++)&#123;</span><br><span class="line">        p[i] = <span class="keyword">new</span> <span class="keyword">int</span>[col];</span><br><span class="line">    &#125;</span><br><span class="line">    p = MAT; <span class="comment">//同类型转换</span></span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看来两行是不够啦，加五行才行。这看起来也挺麻烦的，还不如我手动二重指针建二维数组呢。于是我向老师发出灵魂拷问：</p>
<p><em>老师会更倾向于怎么解决返回二维数组的问题呢</em></p>
<p><em>C中没好办法，可以在函数内部动态分配，返回二重指针。C++中将其封装为类，返回对象即可，但需实现复制构造函数，效率不高</em></p>
<p>就在我以为这个问题真懂了，董老师发来一道思考题！</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> **p;</span><br><span class="line">    <span class="comment">//cout&lt;&lt;"p size is "&lt;&lt;sizeof(p)/sizeof(int)&lt;&lt;endl;</span></span><br><span class="line">    <span class="comment">//cout&lt;&lt;"int size is"&lt;&lt; sizeof(int)&lt;&lt;endl;</span></span><br><span class="line">    <span class="keyword">int</span> m[<span class="number">3</span>][<span class="number">4</span>]=&#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">14</span>&#125;,&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">24</span>&#125;,&#123;<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">34</span>&#125;&#125;; </span><br><span class="line">    p=(<span class="keyword">int</span> **)m; </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt;<span class="string">"m="</span>&lt;&lt;m&lt;&lt;<span class="built_in">endl</span>; </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"m size is "</span>&lt;&lt; <span class="keyword">sizeof</span>(m)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"p="</span>&lt;&lt;p&lt;&lt;<span class="built_in">endl</span>; </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"p size is "</span>&lt;&lt; <span class="keyword">sizeof</span>(p)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"m[1]="</span>&lt;&lt;m[<span class="number">1</span>]&lt;&lt;<span class="built_in">endl</span>; </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"(p+1)="</span>&lt;&lt;(p+<span class="number">1</span>)&lt;&lt;<span class="built_in">endl</span>; </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"p[1]="</span>&lt;&lt;p[<span class="number">1</span>]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"m[2]="</span>&lt;&lt;m[<span class="number">2</span>]&lt;&lt;<span class="built_in">endl</span>; </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"(p+2)="</span>&lt;&lt;(p+<span class="number">2</span>)&lt;&lt;<span class="built_in">endl</span>; </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"p[2]="</span>&lt;&lt;p[<span class="number">2</span>]&lt;&lt;<span class="built_in">endl</span>; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>解释清楚其输出，就清楚了M和p的区别</em></p>
<p>谢天谢地，这不是当年cpp的期末考题，不然当年的78分可拿不到了…</p>
<p>在gcc 7.5.0 CentOS-7 64bit的系统进行测试，结果如下</p>
<p><img src="https://i.loli.net/2020/03/02/wdQKabSZrehot7R.png" alt="批注 2020-03-02 225607.png"></p>
<p>通过观察程序输出，可推断出如下结果:</p>
<ul>
<li>1 不同编译器和系统架构上sizeof(int*) == sizeof(int)不一定永远成立(虽然谭浩强当年如是告诉我成立)。参考此处输出 sizeof(int*)是8 sizeof(int)是4。</li>
<li>2 p和m类型确实不一样。p向后位移1位是1个int*的长度(比较p与(p+1))，而m位移1位是4个int的长度(比较m与m[1])。这证明了p是二重指针，是指向指针的指针；而m是指向一维数组的指针。</li>
<li>3 p[1]有点奇怪，似乎内存地址与p完全无关了。但我猜测访问p[1][0]就会段错误。</li>
</ul>
<p>董老师对第三点进行补充：</p>
<p><em>1.段错误这点没错。因为p[1]仍是一指针，指向内存第2个字节，p[1][0]即读该地址开始的一个整数，程序无权读写</em><br>2.p[1]应是将p偏后一个位置后，取若干字节内容解释成一个指针，具体值与编译器，机器体系结构有关。如果int和int*不一样大，则p[1]是一个整数的一部分，或两个整数的各一部分拼成</p>
<p>此时我的表情只有</p>
<p><img src="https://image.dbbqb.com/Xb0W" alt="avatar"></p>
<h3 id="结语：如何求助？"><a href="#结语：如何求助？" class="headerlink" title="结语：如何求助？"></a>结语：如何求助？</h3><p>其实除了感谢老师，也该反思，应该如何向别人求助。<br>以下这些规则，我会用来约束自己，但从不强求别人也做到。</p>
<ul>
<li>1 擅于提炼问题关键词并运用万能检索术，遇到的大部分问题都会有解答。并强烈建议使用英文+谷歌。</li>
<li>2 对于程序调试类问题，看到报错信息回到第一条。如果是逻辑错，尝试断点跟踪调试分析状态。如果依然不能解决需要他人帮忙，也不要把整个复杂工程砸过去，自行排查最有可能错误的地方，保证他人审查代码不超过100行。</li>
<li>3 没有人有义务帮你答疑，尽全力去表达感谢。虽然也有人说“帮助是互相的”，不过大佬几乎无事麻烦我这种渣渣…</li>
</ul>
<p>求助的终极目的——不是糊弄过眼前的bug或项目，而是真正提高自我啊。就算真有不求回报随时秒回的圣母心大佬，那下次解决问题的勇气，就是来自于我有大佬朋友吗？难道不应该是我有能力独立解决它的信心吗？</p>
<p>哈哈，虽然这么说，但还是希望有机会能多向大佬请教！(毕竟自学cs这条路走得真累…)</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>2d-array</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>texlive + vscode书写中文tex</title>
    <url>/2020/02/24/tex/</url>
    <content><![CDATA[<p>毕业季将至，每想到毕业设计截稿将至则忧心焦虑，不敢再摸鱼冲浪。因此，在vscode上装好texlive，为接下来的成果书写准备一个完美的环境吧~   </p>
<p>网上关于这方面的教程很多，本不必重复再写，但在安装过程中遇到报错<em>vscode Recipe terminated with fatal error: spawn xelatex ENOENT</em>，如你也遇到相似问题，拉到最后尝试下我的方法~</p>
<a id="more"></a>

<h2 id="为什么需要latex？"><a href="#为什么需要latex？" class="headerlink" title="为什么需要latex？"></a>为什么需要latex？</h2><ul>
<li>1 理工科论文书写里会涉及大量数学公式，而latex为排版界的专家，尤其擅长各种数学公式的排版。虽然word也有插入公式的功能，但拆入的符号有限，而且排版较latex差一些。  </li>
<li>2 毕业设计通常各高校会提供模板，一般分为docx和tex版本的。科研期刊更是通常提供tex模板，保证排版美观，同时也减少投稿人在排版上费过多精力。  </li>
</ul>
<p>其实我平时都用markdown，插入数学公式也很方便，但对于<strong>正式学位论文或期刊投稿</strong>等，采用latex进行正规美观排版为主流。  </p>
<p>以及在这篇blog中，我们选择texlive+vscode的组合。原因是：  </p>
<ul>
<li>1 texlive是latex中较为流行的发行版</li>
<li>2 vscode是好用的编辑器。可以理解texlive为tex文件的编译器，我们还需要编辑器。(你当然可以在记事本写好tex然后命令行编译…)texlive安装会提示是否需要texworks，但据说很界面简陋。最初我使用的是texlive+texstudio的组合，但有vscode+万能插件为什么还要studio呢…</li>
</ul>
<h2 id="texlive-vscode基本配置"><a href="#texlive-vscode基本配置" class="headerlink" title="texlive+vscode基本配置"></a>texlive+vscode基本配置</h2><h3 id="使用texlive"><a href="#使用texlive" class="headerlink" title="使用texlive"></a>使用texlive</h3><p>虽然一直说用latex写文档，但latex具有多个发行版，如texlive, MiKTeX, CTex等。这里我们选择texlive(但后面会用到MiKTex)，安装包可从清华源获取  </p>
<p><a href="https://mirrors.tuna.tsinghua.edu.cn/CTAN/systems/texlive/Images/" target="_blank" rel="noopener">tuna_texlive</a> 选择texlive.iso下载即可  </p>
<p>挂载镜像后，单击install-tl-advanced.bat进行安装。可进行<strong>安装路径修改</strong>以及在advanced选项里进行个性化设置(比如不需要前端编辑器)  </p>
<p>点击安装，等待3000+包下载安装  </p>
<p>1h11min后…  </p>
<p>安装后texlive还会进行一些系统配置，结束后关闭选项可用，因此不用心急。  </p>
<p>在cmd逐条进行测试  </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tex -v</span><br><span class="line">latex -v</span><br><span class="line">xelatex -v</span><br><span class="line">pdflatex -v</span><br></pre></td></tr></table></figure>

<p>如能正确返回结果，则表明安装成功。  </p>
<h3 id="配置vscode"><a href="#配置vscode" class="headerlink" title="配置vscode"></a>配置vscode</h3><p>此处默认已安装vscode，安装包可从此处获取。  </p>
<p><a href="https://code.visualstudio.com/download" target="_blank" rel="noopener">vscode</a>  </p>
<p>首先我们需要安装latex的拓展，在扩展商店中搜索<strong>LaTex Workshop</strong>进行安装。  </p>
<p>安装完成后，打开settings.json文件写入相关配置。  </p>
<p>注意settings.json文件，通常具有如下格式  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">item: command&#x2F;path, </span><br><span class="line"># &quot;latex-preview.command&quot;: &quot;xelatex&quot;,</span><br></pre></td></tr></table></figure>

<p>对于item具有多重属性的 采用[]与{}进行分层  </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        "name": "xelatex",</span><br><span class="line">        "tools": [</span><br><span class="line">        "xelatex"</span><br><span class="line">        ]</span><br><span class="line">        &#125;,</span><br></pre></td></tr></table></figure>

<p>对于多个item需要用 , 进行隔开否则会提示报错。  </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">item1: path1,</span><br><span class="line">item2: path2,</span><br></pre></td></tr></table></figure>

<p>针对texlive在vscode的配置，我们需要在vscode中的settings.json中添加如下字段：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">"latex-workshop.latex.recipes": [</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">"name": "xelatex",</span><br><span class="line"></span><br><span class="line">"tools": [</span><br><span class="line"></span><br><span class="line">"xelatex"</span><br><span class="line"></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">"name": "xelatex -&gt; bibtex -&gt; xelatex*2",</span><br><span class="line"></span><br><span class="line">"tools": [</span><br><span class="line"></span><br><span class="line">"xelatex",</span><br><span class="line"></span><br><span class="line">"bibtex",</span><br><span class="line"></span><br><span class="line">"xelatex",</span><br><span class="line"></span><br><span class="line">"xelatex"</span><br><span class="line"></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">],</span><br><span class="line"></span><br><span class="line">"latex-workshop.latex.tools": [</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">"name": "latexmk",</span><br><span class="line"></span><br><span class="line">"command": "latexmk",</span><br><span class="line"></span><br><span class="line">"args": [</span><br><span class="line"></span><br><span class="line">"-synctex=1",</span><br><span class="line"></span><br><span class="line">"-interaction=nonstopmode",</span><br><span class="line"></span><br><span class="line">"-file-line-error",</span><br><span class="line"></span><br><span class="line">"-pdf",</span><br><span class="line"></span><br><span class="line">"%DOC%"</span><br><span class="line"></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">"name": "xelatex",</span><br><span class="line"></span><br><span class="line">"command": "xelatex",</span><br><span class="line"></span><br><span class="line">"args": [</span><br><span class="line"></span><br><span class="line">"-synctex=1",</span><br><span class="line"></span><br><span class="line">"-interaction=nonstopmode",</span><br><span class="line"></span><br><span class="line">"-file-line-error",</span><br><span class="line"></span><br><span class="line">"%DOC%"</span><br><span class="line"></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">"name": "bibtex",</span><br><span class="line"></span><br><span class="line">"command": "bibtex",</span><br><span class="line"></span><br><span class="line">"args": [</span><br><span class="line"></span><br><span class="line">"%DOCFILE%"</span><br><span class="line"></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">],</span><br><span class="line"></span><br><span class="line">"latex-preview.command": "xelatex",</span><br><span class="line">"latex-workshop.view.pdf.viewer": "tab"</span><br></pre></td></tr></table></figure>

<p>完成以上基本配置，打开文件夹新建tex文件，进行文档书写吧~  </p>
<p>提供个hello.tex  </p>
<p>英文</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\documentclass&#123;article&#125;</span><br><span class="line">\begin&#123;document&#125;</span><br><span class="line">Hello world!</span><br><span class="line">\end&#123;document&#125;</span><br></pre></td></tr></table></figure>

<p>中文</p>
<pre><code class="latex">\documentclass[UTF8]{ctexart}
\begin{document}
你好!
\end{document}</code></pre>
<p>编译方式  </p>
<ul>
<li>1 在tex编写界面 点击黄色所圈的√进入tex命令界面</li>
</ul>
<p><img src="https://i.loli.net/2020/02/24/Dfz43lVbvsLFXxk.png" alt="1.png">    </p>
<ul>
<li>2 界面如下 先build 后 view in vscode tab</li>
</ul>
<p><img src="https://i.loli.net/2020/02/24/Ki3L4QzJURXuyxs.png" alt="2.png">  </p>
<p>build我遇到报错！  </p>
<h3 id="terminated-with-fatal-error-spawn-xelatex-ENOENT"><a href="#terminated-with-fatal-error-spawn-xelatex-ENOENT" class="headerlink" title="terminated with fatal error: spawn xelatex ENOENT"></a>terminated with fatal error: spawn xelatex ENOENT</h3><p>十分悲伤，查看log后分析 一般该报错是由于环境变量设置错误或相关包安装不完全导致。<br>如latex -v能正确返回，则说明环境变量设置没问题，因此推测问题是相关包安装不完全导致。<br>因此，安装perl和MikTex<br>列出安装地址  </p>
<p><a href="http://strawberryperl.com" target="_blank" rel="noopener">perl</a><br><a href="https://www.filehorse.com/download-miktex-64/" target="_blank" rel="noopener">MikTex</a>  </p>
<p>这里不得不吐槽的是，perl的下载速度实在感人…<br>以及，MikTex的官网win installer打不开…所以第二个链接来自filehorse，下载的是basic_installer，在本机安装时会下载相关包。  </p>
<p>如果跟我熟的话，我直接传你也行…  </p>
<p>安装完成后，需要对MikTex进行相关设置  </p>
<p><img src="https://i.loli.net/2020/02/24/HXbEAMmrzixLqBD.png" alt="4.png">  </p>
<p>如果缺失包就自动安装(之前选了ask me就会一直弹窗口….)  </p>
<p>进行以上设置后，重启vscode，再次build你的tex文件，就可以完美展现啦  </p>
<p>英文<br><img src="https://i.loli.net/2020/02/24/TzX4OdniZCRQvMG.png" alt="3.png">  </p>
<p>中文  </p>
<p><img src="https://i.loli.net/2020/02/24/go7PJFYGq29zpfX.png" alt="5.png">  </p>
<p>中文需要ctexart包，build时会被MkiTex识别到自动为你安装，还是相当方便的~  </p>
<p>完成latex配置的我十分快乐，就好像论文已经写完了一样~  </p>
<p>关于tex模板，可参考<a href="https://github.com/yernhi/collection-latex-templates" target="_blank" rel="noopener">github仓库</a> 中国各大高校，应用尽有~ 有时git clone速度慢，可以先fork到gitee去再clone。  </p>
<p>很虚，可能写论文时又会遇到奇奇怪怪的bug（想拥有无bug体质啊）后期有空应该会再更？祝大家毕业论文写作一切顺利！！！  </p>
<p>参考博客  </p>
<p><a href="https://stackoverflow.club/install-latex-on-win10/" target="_blank" rel="noopener">https://stackoverflow.club/install-latex-on-win10/</a> </p>
<p><a href="https://zhuanlan.zhihu.com/p/41245817" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/41245817</a></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>texlive</tag>
        <tag>vscode</tag>
        <tag>MiKTeX</tag>
      </tags>
  </entry>
  <entry>
    <title>探究pytorch中的backward函数</title>
    <url>/2020/02/05/backward/</url>
    <content><![CDATA[<p>众所周知 在深度机器学习/机器学习任务中需要对损失函数求梯度<br>一般地 $loss(\overrightarrow{x})$为数量函数<br>则我们知道dim($\frac{\partial l}{\partial x}$)=dim($x$)<br>因此常见代码如下 </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x=torch.randn(<span class="number">3</span>,<span class="number">3</span>,requires_grad=<span class="literal">True</span>)</span><br><span class="line">l=(x*x).sum()</span><br><span class="line">l.backward()</span><br><span class="line">print(x.grad)</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>结果如下</p>
<figure class="highlight md"><table><tr><td class="code"><pre><span class="line">tensor([[ 1.9426, -1.4168, -1.6959],</span><br><span class="line"><span class="code">        [-0.8824,  2.9217, -1.0793],</span></span><br><span class="line"><span class="code">        [ 3.1101, -1.6061, -2.9198]])</span></span><br></pre></td></tr></table></figure>
<p>与我们预期结果一致  </p>
<p>那么 如果我们考虑一般的多元向量函数<br> $\vec{y}=f(\vec{x})$,<br>则 $\vec{y}$ 对 $\vec{x}$ 的梯度则为Jacobian 矩阵:</p>
<p>$$<br>J=\left(\begin{array}{ccc}<br>   \frac{\partial y_{1}}{\partial x_{1}} &amp; \cdots &amp; \frac{\partial y_{1}}{\partial x_{n}}\<br>   \vdots &amp; \ddots &amp; \vdots\<br>   \frac{\partial y_{m}}{\partial x_{1}} &amp; \cdots &amp; \frac{\partial y_{m}}{\partial x_{n}}<br>   \end{array}\right)<br>$$</p>
<p>此时 我们考虑一个数量函数$l=g(\overrightarrow y)$ 则$l$对$\overrightarrow y$的梯度为$v$<br>$v=\left(\begin{array}{ccc}\frac{\partial l}{\partial y_{1}} &amp; \cdots &amp; \frac{\partial l}{\partial y_{m}}\end{array}\right)^{T}$</p>
<p>其实 pytorch的backward()为我们所做的即为计算$J^{T} \cdot v$<br>在$l$是数量函数的前提下 $J^{T} \cdot v$满足如下性质</p>
<p>$$<br>J^{T} \cdot v=\left(\begin{array}{ccc}<br>   \frac{\partial y_{1}}{\partial x_{1}} &amp; \cdots &amp; \frac{\partial y_{m}}{\partial x_{1}}\<br>   \vdots &amp; \ddots &amp; \vdots\<br>   \frac{\partial y_{1}}{\partial x_{n}} &amp; \cdots &amp; \frac{\partial y_{m}}{\partial x_{n}}<br>   \end{array}\right)\left(\begin{array}{c}<br>   \frac{\partial l}{\partial y_{1}}\<br>   \vdots\<br>   \frac{\partial l}{\partial y_{m}}<br>   \end{array}\right)=\left(\begin{array}{c}<br>   \frac{\partial l}{\partial x_{1}}\<br>   \vdots\<br>   \frac{\partial l}{\partial x_{n}}<br>   \end{array}\right)<br>$$</p>
<p>但pytorch并不直接支持多元向量函数$\overrightarrow y=f(\overrightarrow x)$对$\overrightarrow x$求雅可比矩阵<br>例如如下代码  </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x=torch.randn(<span class="number">3</span>,<span class="number">1</span>,requires_grad=<span class="literal">True</span>)</span><br><span class="line">y=<span class="number">3</span>*x*x</span><br><span class="line">y.backward()</span><br></pre></td></tr></table></figure>

<p>则会出现运行报错  </p>
<p>RuntimeError: grad can be implicitly created only for scalar outputs</p>
<p>事实上,pytorch引入这一机制是避免高维的张量复合运算如$\overrightarrow y=f(\overrightarrow x)$ ,$\overrightarrow z=g(\overrightarrow y)$ 求$\overrightarrow z$对 $\overrightarrow y$的梯度。不妨设$\overrightarrow y$是$m\times n$ 矩阵 $\overrightarrow z$是$s\times t$矩阵。则所求为高阶张量形如$s\times t\times m\times n$的四阶张量。随后再考虑$\overrightarrow z$对$\overrightarrow x$的梯度，似乎问题越来越复杂。因此做了grad can be implicitly created only for scalar outputs的规定。  </p>
<p>不过 仔细观察$J^{T} \cdot v$所满足的等式 发现$v$与$y$维度相同 根据backward函数的功能 我们可以传入形状与$y$相同的向量作为函数参数 计算一个<em>类梯度</em>  </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s=torch.randn(<span class="number">3</span>,<span class="number">1</span>,requires_grad=<span class="literal">True</span>)</span><br><span class="line">t=<span class="number">3</span>*s</span><br><span class="line">w=torch.ones_like(t)</span><br><span class="line">t.backward(w)</span><br><span class="line">print(s.grad)</span><br></pre></td></tr></table></figure>

<p>结果为  </p>
<pre><code class="md">tensor([[3.],
<span class="code">        [3.],</span>
<span class="code">        [3.]])</span></code></pre>
<p>可知为t对s的雅可比矩阵与w的点乘。  </p>
<p>如果我们依次传入与t同阶的单位矩阵的各列 则将结果进行拼接可得到雅可比矩阵各个元素的值  </p>
<p>不过对于张量部分的解释我也不满意，当年学微分几何的时候就有点晕…枉为数学系学生呜呜呜</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>pytorch</tag>
        <tag>backward</tag>
      </tags>
  </entry>
  <entry>
    <title>远端jupyter及BERT环境配置</title>
    <url>/2020/02/04/envset-1/</url>
    <content><![CDATA[<p>系统配置: CentOS 7 x86_64 cpu-only<br>普通用户: user  </p>
<h2 id="Ananconda-环境配置"><a href="#Ananconda-环境配置" class="headerlink" title="Ananconda 环境配置"></a>Ananconda 环境配置</h2><ul>
<li>1 安装miniconda<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://mirrors.tuna.tsinghua.edu.cn/anaconda/miniconda/Miniconda3-latest-Linux-x86_64.sh</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>确定将conda加入环境变量  </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">source ~/.bashrc</span><br><span class="line">conda list</span><br></pre></td></tr></table></figure>

<p>如conda list运行正常 则成功安装  </p>
<a id="more"></a>

<h3 id="修改镜像源"><a href="#修改镜像源" class="headerlink" title="修改镜像源"></a>修改镜像源</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/  </span><br><span class="line">conda config --set show_channel_urls yes </span><br><span class="line">vim ~/.condarc</span><br></pre></td></tr></table></figure>

<p>删除 –defaults所在行  </p>
<p>查看url所在行是否对应清华镜像</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">conda info</span><br></pre></td></tr></table></figure>

<h3 id="修改pip源"><a href="#修改pip源" class="headerlink" title="修改pip源"></a>修改pip源</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip install --upgrade pip</span><br><span class="line">pip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple</span><br></pre></td></tr></table></figure>

<ul>
<li>3 创建虚拟环境  </li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">conda create -n my_bert python=3.6</span><br><span class="line">conda activate my_bert</span><br></pre></td></tr></table></figure>

<p>退出虚拟环境  </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">conda deactivate</span><br></pre></td></tr></table></figure>

<h2 id="在虚拟环境中安装bert所需环境"><a href="#在虚拟环境中安装bert所需环境" class="headerlink" title="在虚拟环境中安装bert所需环境"></a>在虚拟环境中安装bert所需环境</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">conda install pytorch torchvision cpuonly -c pytorch  </span><br><span class="line">pip install transformers</span><br><span class="line">pip install tensorflow==1.5.0</span><br><span class="line">pip install --upgrade torch torchvision</span><br><span class="line">pip install jupyter==1.0.0 matplotlib==2.2.2 pandas==0.23.4</span><br></pre></td></tr></table></figure>

<p>按照官网安装pytorch(命令1)后 指定tensorflow(命令3)后<br>出现core dumped的情况  经搜索 需要升级torch版本<br>因此输入命令4  </p>
<h3 id="服务器端notebook用本地浏览器打开"><a href="#服务器端notebook用本地浏览器打开" class="headerlink" title="服务器端notebook用本地浏览器打开"></a>服务器端notebook用本地浏览器打开</h3><p>使用jupyter notebook    </p>
<h4 id="本地客户端"><a href="#本地客户端" class="headerlink" title="本地客户端"></a>本地客户端</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh user@ip -L 8008:localhost:8888</span><br></pre></td></tr></table></figure>

<p>请务必输入 -L 8008:localhost:8888<br>该命令表示端口映射 将服务器的8888端口映射到本客户机的8008端口<br>如果不做端口映射 即使ssh成功也无法打开服务器的jupyter notebook  </p>
<h4 id="远程服务器"><a href="#远程服务器" class="headerlink" title="远程服务器"></a>远程服务器</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd ~</span><br><span class="line">jupyter notebook</span><br></pre></td></tr></table></figure>

<p>在本地打开 <a href="http://localhost:8008/" target="_blank" rel="noopener">http://localhost:8008/</a><br>填入对应token</p>
<h2 id="配置BERT环境"><a href="#配置BERT环境" class="headerlink" title="配置BERT环境"></a>配置BERT环境</h2><ul>
<li>6 获取git仓库地址  </li>
</ul>
<pre><code class="shell">git clone https://gitee.com/VealM/jalammar.github.io.git</code></pre>
<p>对应notebooks/bert中有个不错的入门体验教程<br><a href="https://gitee.com/VealM/jalammar.github.io/blob/master/notebooks/bert/A_Visual_Notebook_to_Using_BERT_for_the_First_Time.ipynb" target="_blank" rel="noopener">A_Visual_Notebook_to_Using_BERT_for_the_first_time.ipynb</a><br>强烈推荐运行在jupyter notebook上体验  </p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>anaconda</tag>
        <tag>jupyter notebook</tag>
        <tag>服务部署</tag>
      </tags>
  </entry>
  <entry>
    <title>亲爱的一苇</title>
    <url>/2020/02/02/blog/</url>
    <content><![CDATA[<p>今天是 2020年2月2日 一苇 22岁生日快乐！  </p>
<p>我还记得我们初遇的盛夏，你穿着裙子笑起来温婉可人。采购东西回宿舍的路上，主动伸出手帮我，当时我在心里感慨：这个女孩子好善解人意呀~后来我慢慢意识到，有些人骨子里的善良与教养总会体现在不经意处。  </p>
<p>于我而言，独自穿行是生命的常态，时常被外界贴上无趣清高的标签也无谓。感谢你愿意走进我，我们在新年音乐会疯狂，在兰州夜色无问西东，在积石堂共赏斜阳。</p>
<a id="more"></a>

<h2 id="一起看过的电影"><a href="#一起看过的电影" class="headerlink" title="一起看过的电影"></a>一起看过的电影</h2><p><img src="https://lh5.googleusercontent.com/proxy/JOmcMPI6fdHGWEvFmTPOM1AzUXHTHh0gHL8mtiDuXCbwxUSt5qGDWhVWkPQfgcCAFsY0rIidowNbXDqTwws" alt="avatar">  </p>
<p>2018年初冬，我们一起去看了《无问西东》。所有角色里，你最喜欢吴岭澜，集文人气质与浪漫于一身。我依稀记得电影里关于真实的探讨：  </p>
<p><em>人把自己置身于忙碌当中，有一种麻木的踏实，但丧失了真实，你的青春也不过只有这些日子。</em>  </p>
<p><em>什么是真实？</em> </p>
<p><em>你看到什么，听到什么，做什么，和谁在一起，有一种，从心灵深处，满溢出来的不懊悔，也不羞耻的平和与喜悦。</em>  </p>
<p>一苇，愿你早已找到属于自己的真实。</p>
<h2 id="一起疯狂的新年音乐会"><a href="#一起疯狂的新年音乐会" class="headerlink" title="一起疯狂的新年音乐会"></a>一起疯狂的新年音乐会</h2><p>记得大二那年，我们背着复习资料去甘肃大剧院听维也纳新年音乐会。<br>曲终人散时，我们被交响乐的美妙深深震撼。<br>返程时坐公交高德忘了让我俩下车，我们一路坐到小西湖。靠着好心人的零钱，在新年钟声敲响前赶回宿舍，在公交车上快乐地祝福彼此新年快乐。  </p>
<p>这或许是孤独如我，大学以来最印象深刻 最有仪式感 最快乐的新年。<br>感谢有你的陪伴。希望多年后我们想起2018新年，热泪盈眶。</p>
<p><img src="https://www.event51.com/image/image/show-event-picture?fileName=2018-06-25_09-25-17__Qttqwul_ae68sGeIeD04yu747qw62gqt.jpg" alt="avatar">  </p>
<h2 id="一起喝过的咖啡"><a href="#一起喝过的咖啡" class="headerlink" title="一起喝过的咖啡"></a>一起喝过的咖啡</h2><p>一苇君超爱喝咖啡的~虽然我喝咖啡常常会胃疼。今年九月初我们穿越大街小巷寻找安静的咖啡厅(别想在咖啡厅自习，放弃吧！少年！)，肥宅如我也算因此见识了兰大附近大大小小的茶饮店/咖啡馆。  </p>
<p>亲爱的一苇，希望未来会有一如你沉静美好的少年，陪伴在你身边，静静看你喝咖啡的模样。  </p>
<p><img src="https://cw1.tw/CH/images/channel_master/34108ffc-dd36-4904-a8f5-2d1eb0570774.jpg" alt="avatar">  </p>
<p>亲爱的一苇，2020年2月2日，22岁，生日快乐！我会一直在你身后，支持你坚定的选择，期待着你的光明未来。</p>
]]></content>
      <categories>
        <category>日常</category>
      </categories>
      <tags>
        <tag>温情</tag>
      </tags>
  </entry>
</search>
